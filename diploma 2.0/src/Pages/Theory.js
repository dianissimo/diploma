import React, { Component } from "react";
import { Container, Tab, Nav, Row, Col } from "react-bootstrap";

import theory_1_pic_1 from '../assets/theory_1_pic_1.png'

import theory_3_pic_1 from '../assets/theory_3_pic_1.png'
import theory_3_pic_2 from '../assets/theory_3_pic_2.png'
import theory_3_pic_3 from '../assets/theory_3_pic_3.png'
import theory_3_pic_4 from '../assets/theory_3_pic_4.png'
import theory_3_pic_5 from '../assets/theory_3_pic_5.png'

import theory_4_pic_1 from '../assets/theory_4_pic_1.png'
import theory_4_pic_2 from '../assets/theory_4_pic_2.png'
import theory_4_pic_3 from '../assets/theory_4_pic_3.png'
import theory_4_pic_4 from '../assets/theory_4_pic_4.png'
import theory_4_pic_5 from '../assets/theory_4_pic_5.png'

import theory_5_pic_1 from '../assets/theory_5_pic_1.png'
import theory_5_pic_2 from '../assets/theory_5_pic_2.png'
import theory_5_pic_3 from '../assets/theory_5_pic_3.png'
import theory_5_pic_4 from '../assets/theory_5_pic_4.png'
import theory_5_pic_5 from '../assets/theory_5_pic_5.png'
import theory_5_pic_6 from '../assets/theory_5_pic_6.png'
import theory_5_pic_7 from '../assets/theory_5_pic_7.png'
import theory_5_pic_8 from '../assets/theory_5_pic_8.png'
import theory_5_pic_9 from '../assets/theory_5_pic_9.png'
import theory_5_pic_10 from '../assets/theory_5_pic_10.png'

import theory_6_pic_1 from '../assets/theory_6_pic_1.png'
import theory_6_pic_2 from '../assets/theory_6_pic_2.png'
import theory_6_pic_3 from '../assets/theory_6_pic_3.png'

import theory_7_pic_1 from '../assets/theory_7_pic_1.png'

import theory_8_pic_1 from '../assets/theory_8_pic_1.png'
import theory_8_pic_2 from '../assets/theory_8_pic_2.png'
import theory_8_pic_3 from '../assets/theory_8_pic_3.png'
import theory_8_pic_4 from '../assets/theory_8_pic_4.png'
import theory_8_pic_5 from '../assets/theory_8_pic_5.png'
import theory_8_pic_6 from '../assets/theory_8_pic_6.png'
import theory_8_pic_7 from '../assets/theory_8_pic_7.png'

import theory_9_pic_1 from '../assets/theory_9_pic_1.png'
import theory_9_pic_2 from '../assets/theory_9_pic_2.png'
import theory_9_pic_3 from '../assets/theory_9_pic_3.png'
import theory_9_pic_4 from '../assets/theory_9_pic_4.png'
import theory_9_pic_5 from '../assets/theory_9_pic_5.png'
import theory_9_pic_6 from '../assets/theory_9_pic_6.png'
import theory_9_pic_7 from '../assets/theory_9_pic_7.png'
import theory_9_pic_8 from '../assets/theory_9_pic_8.png'
import theory_9_pic_9 from '../assets/theory_9_pic_9.png'

import theory_10_pic_1 from '../assets/theory_10_pic_1.png'

import theory_11_pic_1 from '../assets/theory_11_pic_1.png'

import theory_12_pic_1 from '../assets/theory_12_pic_1.png'

import theory_14_pic_1 from '../assets/theory_14_pic_1.png'

import theory_15_pic_1 from '../assets/theory_15_pic_1.png'

import theory_16_pic_1 from '../assets/theory_16_pic_1.png'
import theory_16_pic_2 from '../assets/theory_16_pic_2.png'
import theory_16_pic_3 from '../assets/theory_16_pic_3.png'
import theory_16_pic_4 from '../assets/theory_16_pic_4.png'
import theory_16_pic_5 from '../assets/theory_16_pic_5.png'
import theory_16_pic_6 from '../assets/theory_16_pic_6.png'
import theory_16_pic_7 from '../assets/theory_16_pic_7.png'
import theory_16_pic_8 from '../assets/theory_16_pic_8.png'
import theory_16_pic_9 from '../assets/theory_16_pic_9.png'
import theory_16_pic_10 from '../assets/theory_16_pic_10.png'
import theory_16_pic_11 from '../assets/theory_16_pic_11.png'

import theory_17_pic_1 from '../assets/theory_17_pic_1.png'
import theory_17_pic_2 from '../assets/theory_17_pic_2.png'
import theory_17_pic_3 from '../assets/theory_17_pic_3.png'
import theory_17_pic_4 from '../assets/theory_17_pic_4.png'
import theory_17_pic_5 from '../assets/theory_17_pic_5.png'
import theory_17_pic_6 from '../assets/theory_17_pic_6.png'
import theory_17_pic_7 from '../assets/theory_17_pic_7.png'

import theory_18_pic_1 from '../assets/theory_18_pic_1.gif'
import theory_18_pic_2 from '../assets/theory_18_pic_2.gif'

import theory_19_pic_1 from '../assets/theory_19_pic_1.gif'

import theory_20_pic_1 from '../assets/theory_20_pic_1.gif'


export default class Theory extends Component {
    render() {
        return (
            <Container>
                <Tab.Container id="left-tabs-example" defaultActiveKey="dfs">
                    <Row>
                        <Col sm={3}>
                            <Nav variant="pills" className="flex-column mt-2">
                                <Nav.Item>
                                    <Nav.Link eventKey="theory_1"> Алгоритмы и сложность </Nav.Link>
                                    <Nav.Link eventKey="theory_2"> Полный перебор и оптимизация перебора </Nav.Link>
                                    <Nav.Link eventKey="theory_3"> Жадные алгоритмы </Nav.Link>
                                    <Nav.Link eventKey="theory_4"> Динамическое программирование </Nav.Link>
                                    <Nav.Link eventKey="theory_5"> Рекурсивные алгоритмы </Nav.Link>
                                    <Nav.Link eventKey="theory_6"> Алгоритмы "Разделяй и властвуй" </Nav.Link>
                                    <Nav.Link eventKey="theory_7"> Рандомизированные алгоритмы </Nav.Link>
                                    <Nav.Link eventKey="theory_8"> Двоичный поиск </Nav.Link>
                                    <Nav.Link eventKey="theory_9"> Принципы построения алгоритмов </Nav.Link>
                                    <Nav.Link eventKey="theory_10"> Односвязный список </Nav.Link>
                                    <Nav.Link eventKey="theory_11"> Множество </Nav.Link>
                                    <Nav.Link eventKey="theory_12"> Словарь </Nav.Link>
                                    <Nav.Link eventKey="theory_13"> Стек </Nav.Link>
                                    <Nav.Link eventKey="theory_14"> Очередь с приоритетом </Nav.Link>
                                    <Nav.Link eventKey="theory_15"> Дек </Nav.Link>
                                    <Nav.Link eventKey="theory_16"> Природа графа </Nav.Link>
                                    <Nav.Link eventKey="theory_17"> Представление графа в памяти компьютера </Nav.Link>
                                    <Nav.Link eventKey="theory_18"> Обходы графа </Nav.Link>
                                    <Nav.Link eventKey="theory_19"> Алгоритм нахождения компонент связности в графе </Nav.Link>
                                    <Nav.Link eventKey="theory_20"> Задача поиска кратчайшего пути в графе </Nav.Link>
                                </Nav.Item>
                            </Nav>
                        </Col>
                        <Col sm={9}>
                            <Tab.Content className="mt-3">
                                <Tab.Pane eventKey="theory_1">
                                    <h1> Алгоритмы и сложность </h1>
                                    <br></br>
                                    <h3> Что такое алгоритм? </h3>
                                    <p>
                                        Алгоритм — это последовательность указаний, которые нужно исполнить, чтобы решить 
                                        чётко сформулированную задачу. Мы описываем задачи исходя из ввода и вывода, и 
                                        алгоритм становится способом превращения ввода в вывод. При этом формулировка задачи 
                                        должна быть точной и недвусмысленной — это помогает избежать неверной интерпретации.
                                        Когда вы закончили проектировать алгоритм, необходимо ответить на два важных вопроса: 
                                        "Правильно ли он работает?" и "Сколько времени занимает выполнение?". Разумеется, вас не 
                                        устроит алгоритм, который выдаёт правильный результат лишь в половине случаев или требует 
                                        1000 лет для поиска ответа.
                                    </p>
                                    <br></br>
                                    <h3> Псевдокод </h3>
                                    <p>
                                        Чтобы понять, как работает алгоритм, нам необходимо перечислить шаги, которые он выполняет. 
                                        Для этого мы будем использовать <i> псевдокод </i> — язык, которым пользуются разработчики для 
                                        описания алгоритмов. Он игнорирует многие детали, необходимые в языках программирования, но он 
                                        более точен, чем рецепт из кулинарной книги.
                                    </p>
                                    <h3> Задача и экземпляр задачи </h3>
                                    <p>
                                        Задача описывает класс возможных входных данных. Экземпляр задачи — это один конкретный 
                                        ввод такого класса. Чтобы продемонстрировать понятия задачи и экземпляра задачи, рассмотрим 
                                        следующий пример. Вы оказались в книжном магазине и собираетесь купить книгу за 4.23＄, 
                                        расплатившись купюрой в 5＄. Вам должны вернуть 77 центов в качестве сдачи. Теперь кассир 
                                        принимает решение, как именно это сделать. Согласитесь, неприятно получить горсть из 77 пенни 
                                        или 15 никелей и 2 пенни. Возникает вопрос: как выдать сдачу, не расстроив клиента? Большинство 
                                        кассиров стараются уместить сумму сдачи в наименьшее количество монет.
                                    </p>
                                    <p>
                                        <i> 
                                            Остановитесь и подумайте:
                                            Каково минимальное количество монет номиналом (25, 10, 5, 1), необходимо для сдачи 
                                            в 77 центов? 
                                        </i>
                                    </p>
                                    <p>
                                        Пример с 77 центами представляет собой экземпляр задачи "Размен". Предполагается, 
                                        что есть d номиналов, которые представлены массивом 
                                        c = (c<sub>1</sub>, c<sub>2</sub>, ..., c<sub>d</sub>). Для упрощения будем считать, 
                                        что номиналы даны в порядке убывания. Например, c = (25, 10, 5, 1) для монет, используемых в США.
                                    </p>
                                    <h5> Задача "Размен" </h5>
                                    <p>
                                        Переведите определенное количество денег в данные номиналы, используя как можно меньше монет.
                                        <br></br>
                                        <br></br>
                                        <h6> Входные данные: </h6>
                                        Целое число money и массив из d номиналов c = (c<sub>1</sub>, c<sub>2</sub>, ..., c<sub>d</sub>) 
                                        в порядке убывания (c<sub>1</sub> {'>'} c<sub>2</sub> {'>'} ... {'>'} c<sub>d</sub>).
                                        <br></br>
                                        <br></br>
                                        <h6> Выходные данные: </h6>
                                        Список из d целых чисел i<sub>1</sub>, i<sub>2</sub>, ..., i<sub>d</sub>, в котором 
                                        c<sub>1</sub> * i<sub>1</sub> + c<sub>2</sub> * i<sub>2</sub> + ... + c<sub>d</sub> * i<sub>d</sub> 
                                        = money и i<sub>1</sub> + i<sub>2</sub> + ... + i<sub>d</sub> как можно меньше.
                                    </p>
                                    <p>
                                    Кассиры по всему миру решают эту проблему с помощью простого алгоритма:
                                    </p>
                                    <p>
                                        <pre><code>
                                            {'Change(money, c, d):'}
                                            <br></br>
                                            {'    while money > 0:'}
                                            <br></br>
                                            {'        coin = ... // монета с самым большим номиналом, который не превышает money'}
                                            <br></br>
                                            {'        // дать монету с номиналом coin клиенту'}
                                            <br></br>
                                            {'        money = money - coin'}
                                        </code></pre>
                                    </p>
                                    <p>
                                        Вот быстрая версия Change:
                                        <br></br>
                                        <br></br>
                                        <pre><code>
                                            {'Change(money, c, d):'}
                                            <br></br>
                                            {'    for k in range(1, d + 1):'}
                                            <br></br>
                                            {'        i_k = floor(money / c[k]) // наибольшее количество монет номинала c[k]'}
                                            <br></br>
                                            {'        // дать i_k монет с номиналом c[k] клиенту'}
                                            <br></br>
                                            {'        money = money - c[k] * i_k'}
                                        </code></pre>
                                    </p>
                                    <h3> Корректные и некорректные алгоритмы </h3>
                                    <p>
                                    Мы называем алгоритм корректным, если на каждый получаемый ввод он делает правильный вывод. 
                                    Алгоритм считается некорректным, если хотя бы один ввод приводит к неправильному выводу.
                                    </p>
                                    <p>
                                        <i> 
                                            Остановитесь и подумайте:
                                            Каково минимальное количество монет номиналами (25, 20, 10, 5, 1), необходимое для сдачи в 40 центов? 
                                        </i>
                                    </p>
                                    <p>
                                    Change — это некорректный алгоритм! Представьте сдачу в 40 центов, выданную в номиналах 
                                    c<sub>1</sub> = 25, c<sub>2</sub> = 20, c<sub>3</sub> = 10, c<sub>4</sub> = 5 и c<sub>5</sub> = 1. 
                                    Change привел бы к неправильному результату: он выдал бы 1 четвертак (25 центов), 1 дайм (10 центов) 
                                    и 1 никель (5 центов) вместо 2 монет по двадцать центов. Хоть это и может выглядеть надуманно, 
                                    в 1875 году в США существовала монета в двадцать центов. Насколько мы можем быть уверены, 
                                    что Change выдаст минимальное количество монет в современных номиналах Соединенных Штатов или любой 
                                    другой страны?
                                    </p>
                                    <p>
                                    Чтобы исправить алгоритм Change, нам нужно рассмотреть все возможные комбинации монет с номиналами 
                                    c<sub>1</sub>, c<sub>2</sub>, ..., c<sub>d</sub>, которые дают в сумме money, и выдать комбинацию 
                                    с минимальным количеством монет. Мы рассматриваем только комбинации, в которых 
                                    i<sub>1</sub> {'\u{2264}'} money/c<sub>1</sub> и i<sub>2</sub> {'\u{2264}'} money/c<sub>2</sub> 
                                    (в целом, величина i<sub>k</sub> не должна превышать money/c<sub>k</sub>), в ином случае мы вернем 
                                    большее количество денег, чем money. В псевдокоде, приведенном ниже, используется символ {'\u{2211}'}. 
                                    Он обозначает суммирование: {'\u{2211}'}<sup>m</sup><sub>i = 1</sub> a<sub>i</sub> = 
                                    a<sub>1</sub> + a<sub>2</sub> + ... + a<sub>m</sub>. Псевдокод также использует концепт 
                                    "бесконечность" (обозначается {'\u{221E}'}) в качестве начального значения для smallestNumberOfCoins. 
                                    Реализация описанного подхода на реальных языках программирования может различаться, но сейчас 
                                    подробности для нас не важны.
                                    </p>
                                    <p>
                                        <pre><code>
                                            {'BruteForceChange(money, c, d):'}
                                            <br></br>
                                            {'    smallestNumberOfCoins = \u{221E}'}
                                            <br></br>
                                            {'    for each combinations of coins (i_1,...,i_d)'}
                                            <br></br>
                                            {'    // от (0,...,0) до (money/c[1],...,money/c[d])'}
                                            <br></br>
                                            {'        valueOfCoins = \u{2211} i_k*c_k // сумма по всем k от 1 до d'}
                                            <br></br>
                                            {'        if valueOfCoins = money:'}
                                            <br></br>
                                            {'            numberOfCoins = \u{2211} i_k // суммарное количество монет'}
                                            <br></br>
                                            {'            if numberOfCoins < smallestNumberOfCoins:'}
                                            <br></br>
                                            {'                smallestNumberOfCoins = numberOfCoins'}
                                            <br></br>
                                            {'                change = (i_1, i_2, ... ,i_d)'}
                                            <br></br>
                                            {'    return change'}
                                        </code></pre>
                                    </p>
                                    <p>
                                    Вторая строка повторяется с каждой возможной комбинацией 
                                    (i<sub>1</sub>, i<sub>2</sub>, ..., i<sub>d</sub>) из d индексов и останавливается, 
                                    когда достигает (money/c<sub>1</sub>, money/c<sub>2</sub>, ..., money/c<sub>d</sub>).
                                    </p>
                                    <p>
                                    Как мы можем узнать, что BruteForceChange не содержит ту же проблему, что и Change, — 
                                    неверный результат при каком-то вводе? Раз BruteForceChange рассматривает все возможные 
                                    комбинации номиналов, рано или поздно алгоритм придёт к оптимальному решению и запишет его в 
                                    массив change. В любой комбинации монет, которая даёт в сумме M, должно быть как минимум 
                                    столько же монет, сколько и в оптимальной. Таким образом, BruteForceChange никогда не завершит 
                                    работу с неоптимальным набором change.
                                    </p>
                                    <p>
                                    На данный момент мы ответили только на один из двух важных вопросов об алгоритмах: "Работает ли он?". 
                                    Однако мы не ответили на вопрос: "Сколько времени занимает выполнение?".
                                    </p>
                                    <p>
                                        <i> 
                                        Остановитесь и подумайте:
                                        Сколько примерно итераций цикла for выполняет BruteForceChange?
                                        <br></br>
                                        - money
                                        <br></br>
                                        - money<sup>d</sup>
                                        <br></br>
                                        - d
                                        </i>
                                    </p>
                                    <h3> Быстрые и медленные алгоритмы </h3>
                                    <p>
                                    Настоящие компьютеры требуют определенное количество времени на выполнение таких операций, 
                                    как сложение, вычитание или проверка условий цикла while. Суперкомпьютер может выполнить сложение 
                                    за 10<sup>-10</sup> секунды, а калькулятор — за 10<sup>-5</sup>. Представьте, что у вас есть 
                                    компьютер, которому требуется 10<sup>-10</sup> секунды на выполнение простой операции 
                                    (например, сложения), и вы знаете, сколько операций выполняет какой-то конкретный алгоритм. 
                                    Вы могли бы рассчитать время выполнения алгоритма, просто взяв произведение количества операций 
                                    и времени, которое занимает одна операция. Однако компьютеры постоянно улучшаются, благодаря чему 
                                    им требуется меньше времени на операцию. Так, ваше представление о времени выполнения быстро стало 
                                    бы устаревшим. Вместо того, чтобы рассчитывать время выполнения на каждом компьютере, мы описываем 
                                    время выполнения через общее количество операций, необходимых алгоритму, — это характеристика 
                                    самого алгоритма, а не компьютера, который вы используете.
                                    </p>
                                    <p>
                                    К сожалению, нам не всегда легко определить, сколько операций выполнит алгоритм. Однако если мы 
                                    можем рассчитать количество базовых операций, выполняемых алгоритмом, то это позволит сравнить его 
                                    с другим алгоритмом, решающим ту же задачу. Чтобы мучительно не подсчитывать каждое умножение и 
                                    сложение, можно сравнивать только те участки кода, которые при увеличении размера ввода потребуют 
                                    больше операций.
                                    </p>
                                    <p>
                                    Представьте, что алгоритм A выполняет n<sup>2</sup> операций при вводе размера n, и алгоритм B решает 
                                    ту же задачу за 3n + 2 операций. Какой алгоритм быстрее: A или B? Хотя A и может быть быстрее, чем B, 
                                    при более малом значении n (например, при n между 1 и 3), B будет быстрее при больших значениях n 
                                    (например, n {'>'} 4). Так как f(n) = n<sup>2</sup> — это, в каком-то смысле, более "быстрорастущая" 
                                    функция относительно n, чем g(n) = n. При этом константы 3 и 2 в 3n + 2 не влияют на конкуренцию 
                                    между двумя алгоритмами при больших значениях n. Мы называем A квадратичным алгоритмом и B — линейным. 
                                    A менее эффективен, чем B, потому что он выполняет больше операций для решения задачи, 
                                    когда значение n большое. Так, иногда мы будем допускать неточности при подсчете операций алгоритма: 
                                    поведение алгоритма при маленьком вводе неважно.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_1_pic_1}
                                        alt="theory_1_pic_1"
                                        width={350}
                                    />
                                    <p>
                                    Рассчитаем примерное количество операций, которое потребуется для BruteForceChange при вводе из M 
                                    центов и номиналов (c<sub>1</sub>, c<sub>2</sub>, ..., c<sub>d</sub>). Чтобы рассчитать общее 
                                    количество операций в цикле for, нам необходимо взять примерное число операций, выполняемое при 
                                    каждой итерации, и умножить его на общее количество итераций. В нашем случае количество операций 
                                    можно оценить сверху величиной money/c<sub>1</sub> * money/c<sub>2</sub> * ... * money/c<sub>d</sub>.
                                    </p>
                                    <p>
                                    Такой тип алгоритмов называется экспоненциальным в противоположность квадратичным, кубическим или 
                                    другим полиномиальным алгоритмам. Выражение времени выполнения экспоненциального алгоритма 
                                    использует n<sup>d</sup>, где n и d — это параметры задачи (например, n и d можно произвольно 
                                    сделать большими, изменив ввод для алгоритма). Время выполнения полиномиального алгоритма 
                                    ограничено n<sup>k</sup>, где k — это константа, не связанная с тестовыми данными.
                                    </p>
                                    <p>
                                    Например, алгоритм с временем выполнения n<sup>1</sup> (линейный), n<sup>2</sup> (квадратичный), 
                                    n<sup>3</sup> (кубический) или даже n<sup>2018</sup> будет полиномиальным. Конечно, алгоритм с 
                                    временем выполнения n<sup>2018</sup> не очень практичен. Возможно, даже менее практичен, чем 
                                    некоторые экспоненциальные алгоритмы. Впрочем, разработчики тратят много усилий, чтобы 
                                    проектировать всё более и более быстрые полиномиальные алгоритмы. Раз значение d может быть 
                                    большим при вызове алгоритма с большим количеством номиналов (например, c = (1, 2, 3, 4, 5, ..., 100)), 
                                    мы видим, что выполнение BruteForceChange может потребовать много времени.
                                    </p>
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_2">
                                    <h1> Полный перебор и оптимизация перебора </h1>
                                    <br></br>
                                    <p>
                                    За полвека программисты обнаружили, что многие алгоритмы основаны на схожих концептах, хотя и 
                                    используются для решения разных проблем. Получается, основных методов проектирования алгоритмов 
                                    относительно немного. Некоторые из них мы охватим в задачах, а пока расскажем о наиболее 
                                    распространённых. Последующие примеры можно будет категоризировать по методологии проектирования.
                                    </p>
                                    <p>
                                    Для демонстрации мы рассмотрим очень простую ситуацию, с которой может столкнуться едва ли не 
                                    каждый обладатель беспроводного домашнего телефона.
                                    </p>
                                    <h3> Метод полного перебора </h3>
                                    <p>
                                    Алгоритм, использующий полный перебор (также этот метод называют исчерпывающий поиск или метод 
                                    "грубой силы"), рассматривает все возможные варианты и находит определенное решение. Если бы вы 
                                    искали телефон по такому алгоритму, то игнорировали бы звонок и проверяли бы каждый квадратный 
                                    сантиметр вашего дома. Вряд ли вы бы успели взять трубку, — иначе вашей удаче можно позавидовать, — 
                                    но исчерпывающий поиск гарантирует, что рано или поздно вы найдете телефон, где бы он ни был.
                                    </p>
                                    <p>
                                    BruteForceChange — это алгоритм "грубой силы". Наши задачи включают несколько дополнительных примеров 
                                    таких алгоритмов. Они самые легкие с точки зрения проектирования, но слишком медленные для решения 
                                    более серьёзных задач, нежели самых маленьких. Мы советуем или избегать алгоритмов "грубой силы" 
                                    или находить решения, которые ускоряют их работу.
                                    </p>
                                    <h3> Метод ветвей и границ </h3>
                                    <p>
                                    Если рассмотреть варианты, предложенные алгоритмом "грубой силы", мы увидим, что многие из них можно 
                                    опустить. Эта техника называется методом ветвей и границ.
                                    </p>
                                    <p>
                                    Представьте, что вы прочёсываете первый этаж и слышите, как над вами звонит телефон. Значит, на 
                                    первом этаже и в подвале можно больше не искать — и вы сэкономили себе время.
                                    </p>
                                    <p>
                                    Хотя алгоритмы полного перебора и не подходят для построения эффективных алгоритмов, мы 
                                    рекомендуем использовать их для стресс-тестирования — техники поиска ошибок в алгоритмах.
                                    </p>
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_3">
                                    <h1> Полный перебор и оптимизация перебора </h1>
                                    <br></br>
                                    <p>
                                    Многие алгоритмы — это итерационные процедуры: с каждым повтором они делают выбор 
                                    из определенного количества вариантов. Например, для кассира задача "Размен" может 
                                    быть представлена как последовательность решений: какую монету (из d ценностей) вернуть 
                                    первой, какую второй и так далее. Некоторые из этих вариантов приведут к правильному ответу, 
                                    а некоторые — нет.
                                    </p>
                                    <p>
                                    При каждом повторе жадный алгоритм выбирает "самый привлекательный" вариант. Например, самый 
                                    большой номинал из доступных монет. В случае с американскими деньгами Change использует номиналы 
                                    четвертак (25 центов), дайм (10 центов), никель (5 центов) и пенни (1 цент), чтобы выдать сдачу, 
                                    в данном порядке. Разумеется, мы показывали, как такой "жадный" подход приводит к неправильным 
                                    результатам при добавлении монет некоторых новых номиналов.
                                    </p>
                                    <p>
                                    В примере с телефоном "жадная" стратегия состояла бы в том, чтобы идти на звук, пока вы его не найдете. 
                                    Но есть проблема: между вами и телефоном может оказаться стена (или хрупкая ваза). К сожалению, 
                                    такие сложности часто возникают и в реальных задачах. Во многих случаях "жадный" подход выглядит 
                                    естественным и очевидным, но может оказаться неправильным.
                                    </p>
                                    <p>
                                    В задаче "Бронирование переговорки" вам дается несколько временных отрезков, и нужно выбрать как 
                                    можно больше отрезков таким образом, чтобы ни один из них не пересекался с другим (отрезки 
                                    пересекаются, если у них есть общая точка). Название задачи основано на следующей гипотетической 
                                    ситуации. Представьте, что у вас есть зал для переговоров, и вам присылают заявки на бронирование 
                                    11 компаний.
                                    </p>
                                    <img
                                        className="d-block"
                                        src={theory_3_pic_1}
                                        alt="theory_3_pic_1"
                                        width={200}
                                    />
                                    <br></br>
                                    <p>
                                    Нельзя удовлетворить все запросы (так как некоторые из них пересекаются), но мы хотим 
                                    удовлетворить как можно больше. Для этого мы представим входные данные более удобным способом.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_3_pic_2}
                                        alt="theory_3_pic_2"
                                        width={500}
                                    />
                                    <br></br>
                                    <p>
                                    Так как мы говорим о "жадных" стратегиях, давайте поэкспериментируем с разными "наиболее выгодными"
                                    подходами. Интуиция может нам подсказать, что нужно выбрать самый короткий отрезок, 
                                    удалить пересекающиеся отрезки и повторить данное действие.
                                    </p>
                                    <p>
                                        <i> 
                                        Остановитесь и подумайте:
                                        Всегда ли это приведет к оптимальному решению?
                                        </i>
                                    </p>
                                    <p>
                                    Не факт. В примере ниже такая "жадная" стратегия предлагает решение из одного отрезка посередине. 
                                    Однако есть и решение из двух отрезков, которые не накладываются друг на друга.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_3_pic_3}
                                        alt="theory_3_pic_3"
                                        width={500}
                                    />
                                    <p>
                                    Возможно, логичнее было бы выбрать отрезок слева (тот, что начинается раньше всех), убрать все 
                                    остальные и повторить данное действие.
                                    </p>
                                    <p>
                                        <i> 
                                        Остановитесь и подумайте:
                                        Всегда ли это приведет к оптимальному решению?
                                        </i>
                                    </p>
                                    <p>
                                    Увы, но нет.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_3_pic_4}
                                        alt="theory_3_pic_4"
                                        width={500}
                                    />
                                    <p>
                                        <i> 
                                        Остановитесь и подумайте:
                                        Может, есть и другие "жадные" подходы?
                                        </i>
                                    </p>
                                    <p>
                                    Скажем, что [l, r] — "чемпионский отрезок", если значение его правой границы самое маленькое из 
                                    всех: для любого другого интервала [l', r'], будет актуально r {'\u{2264}'} r'.
                                    </p>
                                    <p>
                                    Оказывается, что следующий "жадный" алгоритм максимизирует количество непересекающихся отрезков: 
                                    выбрать чемпионский отрезок, убрать все пересекающиеся с ним отрезки, повторить выбор.
                                    </p>
                                    <p>
                                        <i> 
                                        Упражнение:
                                        Докажите, что если набор непересекающихся отрезков не содержит чемпионский отрезок, 
                                        то при замене первого отрезка в этом наборе на чемпионский мы получаем набор непересекающихся 
                                        отрезков.
                                        </i>
                                    </p>
                                    <p>
                                    Вот мы и нашли оптимальную "жадную" стратегию. И действительно, если существует решение задачи, 
                                    включающее в себя чемпионский интервал, мы можем выбрать этот интервал на первом шаге и решить 
                                    задачу выбора непересекающихся отрезков из оставшихся.
                                    </p>
                                    <p>
                                    В нашем примере алгоритм работает следующим образом.
                                    </p>
                                    <p>
                                        
                                        - Выбрать сегмент 3 и отбросить сегменты 1, 2, 5 и 9.
                                        <br></br>
                                        - Выбрать сегмент 10 и отбросить сегменты 7 и 8.
                                        <br></br>
                                        - Выбрать сегмент 6.
                                        <br></br>
                                        - Выбрать сегмент 11.
                                        <br></br>
                                        - Выбрать сегмент 4.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_3_pic_5}
                                        alt="theory_3_pic_5"
                                        width={500}
                                    />
                                    <br></br>
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_4">
                                    <h1> Динамическое программирование </h1>
                                    <br></br>
                                    <p>
                                    Некоторые алгоритмы разбивают задачу на более мелкие подзадачи и используют 
                                    решения подзадач, чтобы собрать решение для главной. Во время этого процесса количество 
                                    подзадач может стать очень большим, и некоторые алгоритмы решают одну и ту же подзадачу 
                                    многократно, что чрезмерно увеличивает время выполнения. Динамическое программирование 
                                    упорядочивает вычисления и позволяет не вычислять уже известные значения повторно. 
                                    Зачастую это экономит массу времени.
                                    </p>
                                    <p>
                                    Задача со звонящим телефоном не подразумевает решения с помощью динамического программирования, 
                                    поэтому мы рассмотрим другую. Представьте, что вместо ответа на звонок вы решаете поиграть в 
                                    "Камни": игру для двух игроков с двумя наборами камней по десять штук. С каждым ходом один 
                                    игрок может взять один камень (из любого набора) или два камня (по одному из обоих). 
                                    Когда камень забрали, он выходит из игры. Побеждает игрок, который заберет последний камень. 
                                    Первый ход за вами.
                                    </p>
                                    <p>
                                    Чтобы найти стратегию для выигрыша в игре на 10 + 10, мы можем составить таблицу, которую мы 
                                    назовем R (см. рис.). Вместо того, чтобы решать задачу с 10 камнями в каждом из наборов, мы 
                                    решим более общую задачу с n камней в одном наборе и m камней в другом (игра на n + m), где 
                                    n и m — это произвольные целые неотрицательные числа.
                                    </p>
                                    <p>
                                    Если игрок 1 может гарантированно выигрывать игру на n + m, тогда мы будем говорить, что R(n, m) = W. 
                                    Если у игрока 1 нет стратегии для выигрыша против игрока, который всегда делает правильные ходы, 
                                    мы будем писать R(n, m) = L. Вычисление R(n, m) для произвольных n и m может звучать сложно, 
                                    но мы воспользуемся результатами вычислений для меньших значений. Некоторые варианты игры, — в 
                                    особенности R(0, 1), R(1, 0) и R(1, 1), — явно приведут к победе игрока 1, так как игрок 1 может 
                                    выиграть первым ходом. Таким образом, мы заполняем ячейки (1, 1), (0, 1) и (1, 0) как W.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_4_pic_1}
                                        alt="theory_4_pic_1"
                                        width={200}
                                    />
                                    <p>
                                    Заполнив ячейки (0, 1), (1, 0) и (1, 1), можно попробовать заполнить другие. Например, в случае 
                                    с (2, 0) единственный ход, который может сделать игрок 1, приводит к (1, 0) — это выигрышный 
                                    вариант для оппонента. Аналогичный анализ применим к случаю (0, 2), 
                                    что приводит к таблице из рисунка ниже.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_4_pic_2}
                                        alt="theory_4_pic_2"
                                        width={200}
                                    />
                                    <p>
                                    В случае (2, 1) игрок 1 может сделать три разных хода, которые приведут к (1, 1), (2, 0) и (1, 0) 
                                    соответственно. Один из этих случаев, (2, 0), приводит к проигрышной позиции оппонента. 
                                    Соответственно, (2, 1) — это выигрышная позиция. Случаи (1, 2) и (2, 1) симметричны, поэтому 
                                    мы получаем таблицу из рисунка ниже.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_4_pic_3}
                                        alt="theory_4_pic_3"
                                        width={200}
                                    />
                                    <p>
                                    Теперь мы можем заполнить R(2, 2). В случае (2, 2) игрок 1 может сделать три разных хода, 
                                    которые приведут к ячейкам (2, 1), (1, 2) и (1, 1). Эти ячейки — выигрышные позиции для оппонента. 
                                    Так, R(2, 2) = L: см. рисунок.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_4_pic_4}
                                        alt="theory_4_pic_4"
                                        width={200}
                                    />
                                    <p>
                                    Мы можем продолжить заполнять R, обращая внимание на то, что ячейка (i, j) будет L, если ячейки 
                                    сверху, слева и слева по диагонали будут W. Эти ячейки ((i - 1, j), (i - 1, j - 1) и (i, j - 1)) 
                                    соответствуют трем ходам, которые может сделать игрок 1. См. рис.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_4_pic_5}
                                        alt="theory_4_pic_5"
                                        width={200}
                                    />
                                    <p>
                                    Алгоритм Rocks определяет, выиграет игрок 1 или нет. Если игрок 1 выигрывает n + m, то Rocks выдаст W. 
                                    Если игрок 1 проигрывает, то Rocks выдаст L. Мы ввели искусственное начальное условие, R(0, 0) = L, 
                                    чтобы упростить псевдокод.
                                    </p>
                                    <p>
                                        <pre><code>
                                            {'Rocks(n, m):'}
                                            <br></br>
                                            {'    R(0,0) = L'}
                                            <br></br>
                                            {'    for i from 1 to n:'}
                                            <br></br>
                                            {'        if R(i-1,0) = W:'}
                                            <br></br>
                                            {'            R(i,0) = L'}
                                            <br></br>
                                            {'        else:'}
                                            <br></br>
                                            {'            R(i,0) = W'}
                                            <br></br>
                                            {'    for j from 1 to m:'}
                                            <br></br>
                                            {'        if R(0,j-1) = W:'}
                                            <br></br>
                                            {'            R(0,j) = L'}
                                            <br></br>
                                            {'        else:'}
                                            <br></br>
                                            {'            R(0,j) = W'}
                                            <br></br>
                                            {'    for i from 1 to n:'}
                                            <br></br>
                                            {'        for j from 1 to m:'}
                                            <br></br>
                                            {'            if R(i-1,j-1)=W and R(i,j-1)=W and R(i-1,j)=W:'}
                                            <br></br>
                                            {'                R(i,j) = L'}
                                            <br></br>
                                            {'            else:'}
                                            <br></br>
                                            {'                R(i,j) = W'}
                                            <br></br>
                                            {'    return R(n,m)'}
                                        </code></pre>
                                    </p>
                                    <p>
                                    Более быстрый алгоритм для решения этой головоломки опирается на простую закономерность в 
                                    R и проверяет, чётные n и m или нет. Если оба числа чётные, то игрок проигрывает (см. таблицу выше).
                                    </p>
                                    <p>
                                        <pre><code>
                                            {'FastRocks(n, m):'}
                                            <br></br>
                                            {'    if n % 2== 0 and m % 2 == 0: // оба числа чётные'}
                                            <br></br>
                                            {'        return L'}
                                            <br></br>
                                            {'    else:'}
                                            <br></br>
                                            {'        return W'}
                                        </code></pre>
                                    </p>
                                    <p>
                                    Тем не менее, хотя FastRocks и эффективнее, чем Rocks, изменить его для схожих вариантов игры 
                                    может быть сложно. Например, вариант, в котором игрок может убирать до трёх камней из наборов. 
                                    Перед нами пример того, как более медленный алгоритм может быть полезнее, чем быстрый.
                                    </p>
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_5">
                                    <h1> Рекурсивные алгоритмы </h1>
                                    <br></br>
                                    <p>
                                    Рекурсия — одно из самых распространенных алгоритмических понятий. Если говорить просто, 
                                    то рекурсивным алгоритм становится, если вызывает сам себя.
                                    </p>
                                    <p>
                                    Головоломка Ханойские башни состоит из трёх стержней, пронумеруем их слева направо: 1, 2 и 3. 
                                    Также в головоломке используется стопка дисков с отверстием посередине. Радиус дисков уменьшается 
                                    снизу вверх. Изначально диски расположены на левом стержне (стержень 1), самый большой диск 
                                    находится внизу. Диски в игре перемещаются по одному со стержня на стержень. Диск можно надеть на 
                                    стержень, только если он пустой или верхний диск на нём большего размера, чем перемещаемый. Цель 
                                    головоломки — перенести все диски со стержня 1 на стержень 3. Попробуйте нашу интерактивную версию 
                                    Ханойских башен и узнайте, как переместить все диски с одного стержня на другой.
                                    </p>
                                    <p>
                                    <h6><i>Ханойские башни:</i></h6> 
                                    Вывод списка действий, необходимых для решения головоломки "Ханойские башни".
                                    <br></br>
                                    <br></br>
                                    <h6> Входные данные: </h6>
                                    Целое число n.
                                    <br></br>
                                    <br></br>
                                    <h6> Выходные данные: </h6>
                                    Последовательность ходов для решения головоломки "Ханойские башни" из n дисков.
                                    </p>
                                    <p>
                                    Решить головоломку с одним диском легко — просто переместите его на правый стержень. 
                                    Головоломка на два диска ненамного сложнее. Сначала нужно переместить маленький диск на 
                                    стержень посередине, а большой — на стержень справа. Затем переместить маленький диск на 
                                    большой на правом стержне.
                                    </p>
                                    <p>
                                    Версия на три диска чуть сложнее, но и ее можно решить с помощью следующих семи шагов:
                                    </p>
                                    <p>
                                        - Переместить диск со стержня 1 на стержень 3
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_5_pic_1}
                                        alt="theory_5_pic_1"
                                        width={500}
                                    />
                                    <p>
                                        - Переместить диск со стержня 1 на стержень 2
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_5_pic_2}
                                        alt="theory_5_pic_2"
                                        width={500}
                                    />
                                    <p>
                                        - Переместить диск со стержня 3 на стержень 2
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_5_pic_3}
                                        alt="theory_5_pic_3"
                                        width={500}
                                    />
                                    <p>
                                        - Переместить диск со стержня 1 на стержень 3
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_5_pic_4}
                                        alt="theory_5_pic_4"
                                        width={500}
                                    />
                                    <p>
                                        - Переместить диск со стержня 2 на стержень 1
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_5_pic_5}
                                        alt="theory_5_pic_5"
                                        width={500}
                                    />
                                    <p>
                                        - Переместить диск со стержня 2 на стержень 3
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_5_pic_6}
                                        alt="theory_5_pic_6"
                                        width={500}
                                    />
                                    <p>
                                        - Переместить диск со стержня 1 на стержень 3
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_5_pic_7}
                                        alt="theory_5_pic_7"
                                        width={500}
                                    />
                                    <p>
                                    Теперь давайте посчитаем, сколько шагов потребуется для решения версии на четыре диска. 
                                    Нам нужно обязательно переместить самый большой диск, но для этого придётся сперва поместить 
                                    все остальные диски на пустой стержень. Если у нас не три диска, а четыре, то нужно переложить 
                                    три верхних диска на пустой стержень (7 действий), а затем переместить самый большой диск 
                                    (1 действие). Теперь нужно снова переместить три диска с "временного" стержня на самый большой 
                                    диск (еще 7 действий). Весь процесс будет состоять из 7 + 1 + 7 = 15 действий.
                                    </p>
                                    <p>
                                    Обобщим. Чтобы переместить n дисков с левого стержня на правый, сначала необходимо переместить 
                                    n - 1 дисков на стержень посередине. Затем, когда диск под номером n, самый большой, оказывается 
                                    на правом стержне, нужно переместить на него оставшиеся диски со стержня посередине. Чтобы 
                                    переместить n - 1 дисков со стержня посередине направо, нужно сначала переместить n - 2 дисков на 
                                    стержень слева, затем переместить (n - 1)-й диск вправо, потом переместить n - 2 дисков с левого 
                                    стержня на правый и так далее.
                                    </p>
                                    <p>
                                    На первый взгляд задача "Ханойские башни" может показаться сложной. Тем не менее данный рекурсивный 
                                    алгоритм находит нужные перемещения дисков всего за 8 строк!
                                    </p>
                                    <p>
                                        <pre><code>
                                            {' HanoiTowers(n,fromPeg,toPeg)'}
                                            <br></br>
                                            {'    if n = 1:'}
                                            <br></br>
                                            {'        output “Move disk from peg fromPeg to peg toPeg”'}
                                            <br></br>
                                            {'        return'}
                                            <br></br>
                                            {'    unusedPeg = 6 - fromPeg - toPeg'}
                                            <br></br>
                                            {'    HanoiTowers(n−1,fromPeg,unusedPeg)'}
                                            <br></br>
                                            {'    output “Move disk from peg fromPeg to peg toPeg”'}
                                            <br></br>
                                            {'    HanoiTowers(n−1,unusedPeg,toPeg)'}
                                        </code></pre>
                                    </p>
                                    <p>
                                    Переменные fromPeg, toPeg и unusedPeg указывают на три разных стержня. Таким образом, 
                                    HanoiTowers(n, 1, 3) перемещает диски (n шт.) с первого стержня на третий. Переменная 
                                    unusedPeg указывает, какой из трёх стержней можно использовать для временного хранения 
                                    первых (n - 1) дисков. Обратите внимание, что fromPeg + toPeg + unusedPeg всегда равняется 
                                    1 + 2 + 3 = 6. Таким образом, значение переменной unusedPeg можно определить как 
                                    6 - fromPeg - toPeg. Представленная таблица показывает результаты 6 - fromPeg - toPeg для 
                                    всех возможных переменных fromPeg и toPeg.
                                    </p>
                                    <img
                                        className="d-block"
                                        src={theory_5_pic_8}
                                        alt="theory_5_pic_8"
                                        width={250}
                                    />
                                    <p>
                                    Определив unusedPeg как 6 - fromPeg - toPeg, операторы
                                        <pre><code>
                                            {'HanoiTowers(n−1,fromPeg,unusedPeg)'}
                                            <br></br>
                                            {'output “Move disk from peg fromPeg to peg toPeg”'}
                                            <br></br>
                                            {'HanoiTowers(n−1,unusedPeg,toPeg)'}
                                        </code></pre>
                                    выполняют более простую задачу: они сначала перемещают n - 1 дисков на временный стержень, 
                                    затем перекладывают большой диск, а потом складывают на него оставшиеся n - 1 дисков. 
                                    Обратите внимание, что нет необходимости указывать, какой диск игрок должен переложить 
                                    с fromPeg на toPeg: перемещается всегда тот диск, что является верхним на fromPeg.
                                    </p>
                                    <p>
                                        <i> 
                                            Остановитесь и подумайте:
                                            Сколько нужно действий, чтобы переместить 6 дисков?
                                        </i>
                                    </p>
                                    <p>
                                    Хотя решение Ханойских башен можно уложить в 9 строк псевдокода, его выполнение займет на удивление 
                                    много времени. Решение головоломки на пять дисков состоит из 31 действия. А в решении башни из 
                                    сотни дисков количество действий будет исчисляться “страшными” нонилионами. Такое резкое увеличение 
                                    числа действий для HanoiTowers неудивительно. Заметим, что каждый раз, когда вызывается 
                                    HanoiTowers(n, 1, 3), алгоритм дважды вызывает сам себя для перемещения n - 1 дисков, что запускает 
                                    четыре вызова для перемещения n - 2 дисков и так далее.
                                    </p>
                                    <p>
                                    Это можно проиллюстрировать с помощью рекурсивного дерева, изображенного на рисунке ниже. 
                                    Вызов HanoiTowers(4, 1, 3) приводит к вызовам HanoiTowers(3, 1, 2) и HanoiTowers(3, 2, 3); 
                                    каждый из них вызывает HanoiTowers(2, 1, 3), HanoiTowers(2, 3, 2) и HanoiTowers(2, 2, 1), 
                                    HanoiTowers(2, 1, 3) и так далее. Каждый вызов подпрограммы HanoiTowers занимает определенное время. 
                                    Мы хотим узнать, сколько времени уйдёт на такой алгоритм.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_5_pic_9}
                                        alt="theory_5_pic_9"
                                        width={750}
                                    />
                                    <img
                                        className="d-block m-auto"
                                        src={theory_5_pic_10}
                                        alt="theory_5_pic_10"
                                        width={750}
                                    />
                                    <p>
                                    Чтобы вычислить время выполнения HanoiTowers размера n, мы введём в рассмотрение функцию T(n) — 
                                    количество перемещений дисков, которые выполняет HanoiTowers(n). Получается следующее уравнение 
                                    T(n) = 2 * T(n - 1) + 1. Начиная с T(n) = 1, это рекуррентное соотношение задаёт последовательность 
                                    1, 3, 7, 15, 31, 63 и т.д. Мы можем вычислить T(n), прибавив 1 с обеих сторон и обнаружив, что 
                                    T(n) + 1 = 2 * T(n - 1) + 1 + 1 = 2 * (T(n - 1) + 1). Если мы введём новое обозначение, 
                                    U(n) = T(n) + 1, то U(n) = 2 * U(n - 1). Таким образом, нужно решить следующее рекуррентное 
                                    соотношение: U(n) = 2 * U(n - 1). Начиная с U(1) = 2, получаем последовательность 
                                    2, 4, 8, 16, 32, 64 и т.д. То есть, U(n) = 2<sup>n</sup> и T(n) = U(n) - 1 = 2<sup>n</sup> - 1. 
                                    Следовательно, HanoiTowers(n) — экспоненциальный алгоритм.
                                    </p>
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_6">
                                    <h1> Алгоритмы "Разделяй и властвуй" </h1>
                                    <br></br>
                                    <p>
                                    Одна большая задача может казаться трудной. Но если разделить её на две задачи в два раза меньше, 
                                    она станет намного проще. Для таких случаев хорошо подходят алгоритмы "разделяй и властвуй". 
                                    Они так и работают: разделяют задачу на более мелкие подзадачи, независимо находят решения для них 
                                    и соединяют результаты в решение изначальной задачи. Конечно, реальные ситуации бывают более 
                                    сложными, чем мы описали. После разделения одной задачи на подзадачи, алгоритм обычно делит их на 
                                    ещё более мелкие под-подзадачи и так далее. Он продолжает это делать, пока не дойдёт до точки, где 
                                    в рекурсии уже нет необходимости. Важнейший шаг в работе с алгоритмами "разделяй и властвуй" — это 
                                    соединить решения подзадач в решение изначальной задачи.
                                    </p>
                                    <p>
                                    В качестве примера алгоритма "разделяй и властвуй" приведём задачу сортировки:
                                    </p>
                                    <p>
                                        <h6><i>Сортировка:</i></h6> 
                                        Отсортируйте набор целых чисел.
                                        <br></br>
                                        <br></br>
                                        <h6> Входные данные: </h6>
                                        Список из n разных чисел a = (a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>).
                                        <br></br>
                                        <br></br>
                                        <h6> Выходные данные: </h6>
                                        Отсортированный список целых чисел. Измененный порядок 
                                        (b<sub>1</sub>, b<sub>2</sub>, ..., b<sub>n</sub>) целых чисел от a, где 
                                        b<sub>1</sub> {'<'} b<sub>2</sub> {'<'} ... {'<'} b<sub>n</sub>.
                                    </p>
                                    <p>
                                    SelectionSort — это простой итерационный метод решения задачи по сортировке. 
                                    Сначала он находит самый маленький элемент в a, а затем меняет его местами с первым элементом 
                                    (то есть с a<sub>1</sub>). Затем он находит второй самый маленький элемент в a и переставляет 
                                    его на второе место, меняя элемент местами с a<sub>2</sub>. Повторяя это действие в i-й раз, 
                                    SelectionSort находит i-й самый маленький элемент в a и переставляет его на i-е место.
                                    </p>
                                    <p>
                                    Если a = (7, 92, 87, 1, 4, 3, 2, 6), SelectionSort(a) будет состоять из следующих семи шагов:
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_6_pic_1}
                                        alt="theory_6_pic_1"
                                        width={250}
                                    />
                                    <p>
                                    Время выполнения SelectionSort квадратично, то есть O(n<sup>2</sup>): используется n итераций, 
                                    для каждого из которых требуется время, чтобы просканировать не более n элементов и найти самый 
                                    большой из них для суффикса a. Обратите внимание, что n<sup>2</sup> — это завышенная оценка времени 
                                    выполнения, так как при i-м повторе SelectionSort сканирует суффикс размером n - i + 1: при первой 
                                    итерации находится максимальное значение в массиве размера n, при второй итерации сканируется 
                                    массив размера n - 1 и так далее. Тем не менее общее время выполнения растёт как n<sup>2</sup>:
                                    n + (n - 1) + (n - 2) + ... + 2 + 1 = n(n + 1)/2.
                                    </p>
                                    <p>
                                    MergeSort — классический пример алгоритма "разделяй и властвуй" для сортировки. Он намного быстрее, 
                                    чем SelectionSort. Начнём с задачи слияния, в которой нам нужно будет объединить два отсортированных 
                                    списка — List<sub>1</sub> и List<sub>2</sub> — в один отсортированный список.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_6_pic_2}
                                        alt="theory_6_pic_2"
                                        width={600}
                                    />
                                    <p>
                                    Алгоритм Merge объединяет два отсортированных списка в один за время 
                                    O(|List<sub>1</sub>| + |List<sub>2</sub>|). Для этого алгоритм повторно выбирает самый маленький 
                                    элемент из оставшихся в List<sub>1</sub> и List<sub>2</sub> и перемещает его в растущий 
                                    отсортированный список.
                                    </p>
                                    <p>
                                        <pre><code>
                                            {'Merge(List_1,List_2):'}
                                            <br></br>
                                            {'    SortedList = ... // empty list'}
                                            <br></br>
                                            {'    while both List_1 and List_2 are non-empty:'}
                                            <br></br>
                                            {'    if the smallest element in List_1 is smaller than the smallest element in List_2:'}
                                            <br></br>
                                            {'        move the smallest element from List_1 to the end of SortedList'}
                                            <br></br>
                                            {'    else:'}
                                            <br></br>
                                            {'        move the smallest element from List_2 to the end of SortedList'}
                                            <br></br>
                                            {'    move any remaining elements from either List_1 or List_2 to the end of SortedList'}
                                            <br></br>
                                            {'    return SortedList'}
                                        </code></pre>
                                    </p>
                                    <p>
                                    Merge — полезный инструмент для сортировки произвольного списка, если мы знаем, как разделить 
                                    неотсортированный список на две отсортированные половины. Вам может показаться, что мы вернулись 
                                    к тому, с чего начали, только теперь нам нужно отсортировать два меньших списка вместо одного 
                                    большого. Но сортировка двух мелких списков — более предпочтительная алгоритмическая задача. 
                                    Чтобы понять, почему это так, мы рассмотрим алгоритм MergeSort. Он разделяет неотсортированный 
                                    список на две части и использует рекурсию для выполнения мелких задач перед тем, как объединить 
                                    отсортированные списки.
                                    </p>
                                    <p>
                                        <pre><code>
                                            {'MergeSort(List):'}
                                            <br></br>
                                            {'     if List consists of a single element:'}
                                            <br></br>
                                            {'        return List'}
                                            <br></br>
                                            {'     FirstHalf = first half of List'}
                                            <br></br>
                                            {'     SecondHalf = second half of List'}
                                            <br></br>
                                            {'     SortedFirstHalf = MergeSort(FirstHalf)'}
                                            <br></br>
                                            {'     SortedSecondHalf = MergeSort(SecondHalf)'}
                                            <br></br>
                                            {'     SortedList = Merge(SortedFirstHalf,SortedSecondHalf)'}
                                            <br></br>
                                            {'     return SortedList'}
                                        </code></pre>
                                    </p>
                                    <p>
                                        <i> 
                                            Остановитесь и подумайте:
                                            Каково время выполнения MergeSort?
                                        </i>
                                    </p>
                                    <p>
                                    На рисунке ниже изображено рекурсивное дерево MergeSort, состоящее из log<sub>2</sub>n уровней, 
                                    где n — размер изначального неотсортированного списка. На нижнем уровне нам нужно объединить два 
                                    отсортированных списка размером примерно в n/2 элементов, что займёт O(n/2 + n/2) = O(n) времени. 
                                    На следующем самом высоком уровне нам нужно объединить четыре списка из n/4 элементов, что 
                                    потребует O(n/4 + n/4 + n/4 + n/4) = O(n) времени. Такой шаблон можно описать следующим образом: 
                                    i-й уровень состоит из 2<sup>i</sup> списков, каждый из которых включает в себя приблизительно 
                                    n/2<sup>i</sup> элементов и занимает O(n) времени для объединения. Так как в рекурсивном дереве 
                                    log<sub>2</sub>n уровней, выполнение MergeSort потребует в общем O(n log<sub>2</sub>n) времени, 
                                    что даёт нам большое ускорение по сравнению с более наивным O(n<sup>2</sup>) алгоритмом сортировки.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_6_pic_3}
                                        alt="theory_6_pic_3"
                                        width={500}
                                    />
                                    <br></br>
                                    <br></br>
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_7">
                                    <h1> Рандомизированные алгоритмы </h1>
                                    <br></br>
                                    <p>
                                    Если у вас есть монетка, то прежде чем начать искать телефон, вы можете подбросить её и решить, 
                                    откуда начать поиск: если выпадет решка, то сначала ищем на первом этаже, если орёл — на втором. 
                                    А для выбора конкретной комнаты можно использовать игральный кубик. Хотя бросать монеты и кубики 
                                    весело, этот подход однозначно не интуитивен. К тому же непонятно, даёт ли это алгоритмическое 
                                    преимущество по сравнению с детерминированным алгоритмом. Наши задачи помогут разобраться, в каких 
                                    ситуациях вероятностные алгоритмы будут лучше детерминированных.
                                    </p>
                                    <p>
                                    Чтобы продемонстрировать пример вероятностного алгоритма, обсудим сначала быстрый метод сортировки, 
                                    который называется QuickSort. Для упрощения будем считать, что все элементы данного массива c разные.
                                    </p>
                                    <p>
                                    QuickSort выбирает элемент m (например, первый) из c и просто разделяет массив на два подмассива: 
                                    c<sub>small</sub>, в который входят все элементы c меньше m; и c<sub>large</sub>, в который входят 
                                    все элементы больше m.
                                    </p>
                                    <p>
                                    Это разделение можно выполнить за линейное время, далее, следуя стратегии "разделяй и властвуй", 
                                    QuickSort рекурсивно сортирует каждый подмассив. Итоговый отсортированный список может быть легко 
                                    получен с помощью конкатенации отсортированного c<sub>small</sub>, элемента m и отсортированного 
                                    c<sub>large</sub>.
                                    </p>
                                    <p>
                                        <pre><code>
                                            {'QuickSort(c):'}
                                            <br></br>
                                            {'     if |c| = 1: // только один элемент'}
                                            <br></br>
                                            {'        return c'}
                                            <br></br>
                                            {'     m = c[1] // возьмем первый элемент c'}
                                            <br></br>
                                            {'     // определим элементы c_small меньше m'}
                                            <br></br>
                                            {'     QuickSort(c_small)'}
                                            <br></br>
                                            {'     // определим элементы c_large больше m'}
                                            <br></br>
                                            {'     QuickSort(c_large)'}
                                            <br></br>
                                            {'     // объединим c_small, m и c_large в сортированный список c_sorted'}
                                            <br></br>
                                            {'     return c_sorted'}
                                        </code></pre>
                                    </p>
                                    <p>
                                    Для данного подхода требуется выделить дополнительную память, в которой будут храниться массивы 
                                    c<sub>small</sub> и c<sub>large</sub>. Лучший подход — переставить элементы входного массива на 
                                    месте, чтобы набор c<sub>small</sub> шёл первым, затем m, а затем c<sub>large</sub> (см. ниже) — 
                                    однако неясно, как это сделать.
                                    </p>
                                    <p>
                                        <i> 
                                        Упражнение:
                                        Нико Ломуто предложил изящный алгоритм, позволяющий выполнить такую перестановку элементов на 
                                        месте. Рисунок ниже показывает, как работает разбиение Ломуто. Посмотрите на рисунок. Сможете ли 
                                        вы воссоздать логику подхода Ломуто?
                                        </i>
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_7_pic_1}
                                        alt="theory_7_pic_1"
                                        width={250}
                                    />
                                    <p>
                                    Оказывается, что время выполнения QuickSort зависит от нашей удачи при отборе элемента m. Если мы 
                                    выберем m так, что массив c разделяется на две равные части (то есть |c<sub>small</sub>| = 
                                    |c<sub>large</sub>|), тогда T(n) = 2T(n/2) + a * n, где T(n) означает время, которое требуется 
                                    QuickSort для сортировки массива из n чисел, и a * n означает время, которое потребуется для 
                                    разделения массива длины n на две части; a — положительная константа. Это абсолютно такое же 
                                    рекуррентное соотношение, как и в MergeSort, соответствующее времени выполнения O(n log<sub>2</sub>n).
                                    </p>
                                    <p>
                                    Тем не менее если мы выберем m так, что c разделится неровно (например, возникает крайний случай, 
                                    когда набор c<sub>small</sub> пуст, а в наборе c<sub>large</sub> n - 1 элементов), тогда рекуррентное 
                                    соотношение будет T(n) = T(n - 1) + a * n. Это соотношение и приводит к времени выполнения 
                                    O(n<sup>2</sup>), а этого мы пытаемся избежать. Сортировка массива (n, n - 1, ..., 2, 1) с помощью 
                                    QuickSort действительно занимает квадратичное время. Что ещё хуже, на обработку (1, 2, ..., n - 1, n) 
                                    требуется время O(n<sup>2</sup>). Это выглядит излишним, ведь массив уже отсортирован.
                                    </p>
                                    <p>
                                    Пока что алгоритм QuickSort похож на плохую имитацию MergeSort. Однако если мы сможем выбрать хороший 
                                    "разделитель" m, который разбивает массив на две равные части, мы сможем улучшить время выполнения. 
                                    На самом деле, не обязательно пытаться достичь идеального разделения (50/50), чтобы получить время 
                                    выполнения O(n log n). Например, также подойдет разделение на примерно равные части (скажем, 51/49). 
                                    Фактически можно доказать, что алгоритм будет иметь время выполнения O(n log n) при условии, что 
                                    оба набора c<sub>small</sub> и c<sub>large</sub> больше, чем n/4.
                                    </p>
                                    <p>
                                    Из этого следует, что из n возможных вариантов для m, выбранного в качестве элементов массива c, 
                                    как минимум 3n/4 - n/4 = n/2 хорошо подойдут для разделения! Другими словами, если мы возьмем m 
                                    случайным образом (вероятность выбрать любой из элементов c одинакова), то у нас будет шанс 50% 
                                    получить хорошее разделение. Такой вывод ложится в основу следующего вероятностного алгоритма:
                                    </p>
                                    <p>
                                        <pre><code>
                                            {'RandomizedQuickSort(c):'}
                                            <br></br>
                                            {'     if |c| = 1: // только один элемент'}
                                            <br></br>
                                            {'        return c'}
                                            <br></br>
                                            {'     m = ... // возьмем случайный элемент из c'}
                                            <br></br>
                                            {'     // определим элементы c_small меньше m'}
                                            <br></br>
                                            {'     RandomizedQuickSort(c_small)'}
                                            <br></br>
                                            {'     // определим элементы c_large больше m'}
                                            <br></br>
                                            {'     RandomizedQuickSort(c_large)'}
                                            <br></br>
                                            {'     // объединим c_small, m и c_large в сортированный список c_sorted'}
                                            <br></br>
                                            {'     return c_sorted'}
                                        </code></pre>
                                    </p>
                                    <p>
                                    На практике RandomizedQuickSort — это быстрый алгоритм. Однако его худшее время выполнения остается 
                                    O(n<sup>2</sup>), так как все еще есть вероятность, что он выберет плохой разделитель. При одном и 
                                    том же вводе поведение вероятностного алгоритма отличается от одного выполнения к другому. Тем не 
                                    менее мы можем доказать, что его ожидаемое время выполнения — O(n log n). Слово "ожидаемое" подмечает 
                                    следующий эффект. Так как RandomizedQuickSort — это вероятностный алгоритм, два разных запуска 
                                    (при одинаковом вводе) могут занять разное количество времени: некоторые будут быстрыми, 
                                    некоторые — медленными. Таким образом, время выполнения вероятностного алгоритма — это случайная 
                                    величина. Разработчики нередко интересуются средним значением этой случайной величины, что и 
                                    называется ожидаемым временем выполнения. Можно продемонстрировать, что для каждого массива 
                                    размером в n ожидаемое время выполнения RandomizedQuickSort будет O(n log n).
                                    </p>
                                    <p>
                                    Главное преимущество вероятностных алгоритмов — это производительность. Вероятностные алгоритмы 
                                    решают многие реальные задачи быстрее (с точки зрения ожидаемого времени выполнения), чем 
                                    детерминированные алгоритмы. Еще одна привлекательная особенность — это их простота. Она 
                                    демонстрируется, например, в RandomizedQuickSort.
                                    </p>
                                    <p>
                                    Мы подчеркиваем, что хотя RandomizedQuickSort и принимает решения случайным образом, он всегда 
                                    выдаёт правильное решение задачи сортировки. Единственный изменяющийся параметр от одного прогона 
                                    к другому — это время выполнения, но не результат. В противоположность этому, другие вероятностные 
                                    алгоритмы обычно приводят к неправильным (или точнее, приблизительным) решениям. Вероятностные 
                                    алгоритмы, которые всегда дают верные решения, называются Лас-Вегас. Алгоритмы, которые не приводят 
                                    к верным решениям — Монте-Карло.
                                    </p>
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_8">
                                    <h1> Двоичный поиск </h1>
                                    <br></br>
                                    <h3> Разделяй и властвуй </h3>
                                    <p>
                                    В этом параграфе вы узнаете об алгоритмах "разделяй и властвуй", которые помогают выполнять поиск 
                                    по огромным базам данных в миллион раз быстрее, чем алгоритмы исчерпывающего поиска. Вооружившись 
                                    этой техникой, вы узнаете, что стандартный способ умножать числа (которому вас учили в начальной 
                                    школе) далеко не самый быстрый. Затем мы применим подход "разделяй и властвуй", чтобы 
                                    спроектировать быстрые алгоритмы для сортировки. Вы узнаете, что эти алгоритмы оптимальны — то 
                                    есть даже легендарный ученый Алан Тьюринг не смог бы спроектировать алгоритм сортировки быстрее!
                                    </p>
                                    <h5>Основная идея</h5>
                                    <p>
                                    Если вы хотите решить задачу с помощью стратегии "разделяй и властвуй", вам нужно подумать о 
                                    следующих трёх шагах:
                                    <br></br>
                                    - Разделение задачи на подзадачи поменьше.
                                    <br></br>
                                    - Рекурсивное решение каждой подзадачи.
                                    <br></br>
                                    - Объединение выполненных подзадач в решение изначальной задачи.
                                    <br></br>
                                    Первые два шага — это и есть "разделяй", а последний — "властвуй". Мы продемонстрируем такой 
                                    подход в нескольких примерах, сложность которых будет возрастать.
                                    </p>
                                    <h5>Угадать число</h5>
                                    <p>
                                    Игра "Угадать число" состоит в том, что оппонент загадывает целое число 
                                    1 {'\u{2264}'} x {'\u{2264}'} n. Вы задаёте вопрос: "x = y?". Оппонент отвечает либо "да", либо 
                                    x {'<'} y (то есть "мое число меньше"), либо x {'>'} y (то есть "мое число больше"). 
                                    Ваша задача — получить ответ "да", задав минимальное количество вопросов.
                                    </p>
                                    <p>
                                    Пусть n = 3: ваша задача — угадать 1 {'\u{2264}'} x {'\u{2264}'} 3, задав не больше двух вопросов.
                                    </p>
                                    <p>
                                    Вы можете спросить: "x = 1?". Если ответ положительный, то вы победили. Но оппонент может ответить: 
                                    "x {'>'} 1". Вы решаете, что x равен 2 или 3, но у вас остаётся только один вопрос. Точно так же 
                                    вы можете спросить: "x = 3?". Тогда ваш оппонент может ответить: "x {'<'} 3". В этом случае вы не 
                                    сможете получить желаемый положительный ответ, задав лишь один вопрос.
                                    </p>
                                    <p>
                                    Посмотрим, что будет, если вы сначала спросите: "x = 2?". Если оппонент отвечает, что x = 2, тогда 
                                    игра окончена. Если ответ — x {'<'} 2, то вы уже знаете, что x = 1. Следовательно, второй раз вы 
                                    просто спрашиваете: "x = 1?". И теперь вы получаете положительный ответ. Если оппонент ответит, что 
                                    x {'>'} 2, то вы спрашиваете: "x = 3?". Ответ на него: "Да".
                                    </p>
                                    <p>
                                        <i> 
                                        Упражнение:
                                        Угадать целое число 1 {'\u{2264}'} x {'\u{2264}'} 7, задав не больше трёх вопросов.
                                        </i>
                                    </p>
                                    <p>
                                    Вы уже могли догадаться, что мы начнём с вопроса: "x = 4?". Дело в том, что в обоих случаях — 
                                    x {'<'} 4 и x {'>'} 4 — мы сокращаем пространство поиска с 7 до 3 вариантов (нам уже известно, 
                                    как решить задачу с 3 возможными вариантами):
                                    <br></br>
                                    - если x {'<'} 4, то x будет 1, 2 или 3;
                                    <br></br>
                                    - если x {'>'} 4, то x будет 5, 6 или 7;
                                    <br></br>
                                    Это означает, что в обоих случаях вы можете воспользоваться решением разобранного ранее случая 
                                    n = 3. Получившийся протокол вопросов показан на рисунке.
                                    </p>
                                    <p>
                                    Следующий код имитирует процесс угадывания. Функция query "знает" целое число x. Вызов query(y) 
                                    сообщает нам: x = y, или x {'<'} y, или x {'>'} y. Функция guess() находит число x с помощью вызова 
                                    query(). Она вызывается с двумя параметрами: lower и upper — так, чтобы 
                                    lower {'\u{2264}'} x {'\u{2264}'} upper, то есть x находится в сегменте [lower, upper]. Сначала она 
                                    рассчитывает середину (middle) сегмента [lower, upper], затем вызывает query(middle). Если 
                                    x {'<'} middle, тогда она продолжает работать с интервалом [lower, middle - 1]. Если x {'>'} middle, 
                                    тогда она переходит к интервалу [middle + 1, upper].
                                    </p>
                                    <p>
                                        <pre><code>
                                            {'query(y):'}
                                            <br></br>
                                            {'    x = 1618235'}
                                            <br></br>
                                            {'    if x == y:'}
                                            <br></br>
                                            {'        return \'equal\''}
                                            <br></br>
                                            {'    if x < y:'}
                                            <br></br>
                                            {'        return \'smaller\''}
                                            <br></br>
                                            {'    else:'}
                                            <br></br>
                                            {'        return \'greater\''}
                                            <br></br>
                                            <br></br>
                                            <br></br>
                                            {'guess(lower, upper):'}
                                            <br></br>
                                            {'    middle = (lower + upper) / 2 // целочисленное деление'}
                                            <br></br>
                                            {'    answer = query(middle)'}
                                            <br></br>
                                            {'    // можно напечатать запрос и соответствующий результат'}
                                            <br></br>
                                            {'    if answer == \'equal\':'}
                                            <br></br>
                                            {'        return'}
                                            <br></br>
                                            {'    if answer == \'smaller\':'}
                                            <br></br>
                                            {'        guess(lower, middle - 1)'}
                                            <br></br>
                                            {'    else:'}
                                            <br></br>
                                            {'        guess(middle + 1, upper)'}
                                            <br></br>
                                            <br></br>
                                            <br></br>
                                            {'guess(1, 2097151) // начальный возможный диапазон значений'}
                                        </code></pre>
                                    </p>
                                    <p>
                                    Реализуйте этот алгоритм, измените значение x и запустите код, чтобы увидеть последовательность 
                                    вопросов (удостоверьтесь, что x находится в сегменте, который используется при вызове guess).
                                    </p>
                                    <p>
                                    В целом стратегия, угадывающая целое число 1 {'\u{2264}'} x {'\u{2264}'} n, потребует около 
                                    log<sub>2</sub>n вопросов. Напомним, что log<sub>2</sub>n равняется b, если 2<sup>b</sup> = n. 
                                    Это значит, что если мы продолжим делить n на 2, пока не получим 1, будет около log<sub>2</sub>n 
                                    операций деления. Важно здесь то, что log<sub>2</sub>n — медленно растущая функция. К примеру, если 
                                    n {'\u{2264}'} 10<sup>9</sup>, то log<sub>2</sub>n {'<'} 30.
                                    </p>
                                    <h5>Поиск по отсортированным данным</h5>
                                    <p>
                                    Метод, который мы использовали для угадывания числа, известен как двоичный поиск. Пожалуй, самый 
                                    важный случай применения двоичного поиска — это поиск по отсортированным данным. Поиск — 
                                    фундаментальная задача: имея последовательность и элемент x, мы хотим проверить, входит ли x в 
                                    последовательность. Например, 3 входит в последовательность (7, 2, 5, 6, 11, 3, 2, 9), а 4 — не входит. 
                                    Зная о важности задачи по поиску, неудивительно, что методы для её решения есть почти во всех 
                                    языках программирования.
                                    <pre><code>
                                        <br></br>
                                        {'print(3 in [7, 2, 5, 6, 11, 3, 2, 9])'}
                                        <br></br>
                                        {'print(4 in [7, 2, 5, 6, 11, 3, 2, 9])'}
                                        <br></br>
                                    </code></pre>
                                    Что происходит внутри, когда мы вызываем метод in? Ожидаемо, Python выполняет линейное сканирование. 
                                    На это требуется n сравнений при последовательности длиной n. Если в последовательность не входит x, 
                                    нам необходимо просканировать все элементы: если мы будем пропускать, то мы не можем точно знать, 
                                    отсутствует ли x.
                                    </p>
                                    <p>
                                    Ситуация кардинально меняется, если полученные данные отсортированы, то есть составляют собой 
                                    отсортированную последовательность a<sub>0</sub>, ..., a<sub>n - 1</sub> в порядке возрастания.
                                    </p>
                                    <p>
                                    Оказывается, что в этом случае достаточно около log<sub>2</sub>n сравнений! Это значительное 
                                    ускорение: линейный поиск по отсортированному массиву с миллиардом элементов потребует миллиарда 
                                    сравнений, двоичному же поиску будет достаточно не больше log<sub>2</sub>10<sup>9</sup> {'<'} 30!
                                    </p>
                                    <h3> Двоичный поиск </h3>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_8_pic_1}
                                        alt="theory_8_pic_1"
                                        width={500}
                                    />
                                    <p>
                                        Ваша задача — найти индекс элемента в сортированной последовательности равного q.
                                        <br></br>
                                        <br></br>
                                        <h6> Формат ввода: </h6>
                                        Отсортированный массив K неповторяющихся целых чисел и целое число q. Первые две строки ввода 
                                        содержат целое число n и последовательность k<sub>0</sub> {'<'} k<sub>1</sub> {'<'} ... 
                                        {'<'} k<sub>n - 1</sub> из n неповторяющихся положительных целых чисел в возрастающем порядке. 
                                        Следующая строка содержит целое число q.    
                                        <br></br>
                                        <br></br>
                                        <h6> Формат вывода: </h6>
                                        Позиция элемента в K равного q или -1 при отсутствии такого элемента.
                                        <br></br>
                                        <br></br>
                                        <h6> Ограничения: </h6>
                                        1 {'\u{2264}'} n {'\u{2264}'} 3 * 10<sup>4</sup>;
                                        1 {'\u{2264}'} k<sub>i</sub> {'\u{2264}'} 10<sup>9</sup>
                                        для всех
                                        0 {'\u{2264}'} i {'<'} n;
                                        1 {'\u{2264}'} q {'\u{2264}'} 10<sup>9</sup>.
                                        <br></br>
                                        <br></br>
                                        <h6>Примеры:</h6>
                                        <img
                                            className=""
                                            src={theory_8_pic_2}
                                            alt="theory_8_pic_2"
                                            width={250}
                                        />
                                        <img
                                            className=""
                                            src={theory_8_pic_3}
                                            alt="theory_8_pic_3"
                                            width={250}
                                        />
                                    </p>
                                    <p>
                                    Можно решить эту задачу примитивным способом — просканировать массив K (время выполнения составит 
                                    O(n)). Время решения этой задачи для алгоритма BinarySearch — O(log n). Он инициализируется при 
                                    присвоении minIndex значения 0 и maxIndex значения n - 1. Сначала алгоритм присваивает midIndex 
                                    значение (minIndex + maxIndex)/2, а затем проверяет, больше q, чем K[midIndex], или нет. Если q 
                                    больше, чем это значение, то BinarySearch проводит итерацию на подмассиве K от minIndex до 
                                    midIndex - 1. В ином случае он проводит итерацию на подмассиве K от midIndex + 1 до maxIndex. 
                                    В конечном счёте алгоримт определит, находится q в K или нет.
                                    </p>
                                    <p>
                                        <pre><code>
                                            {'BinarySearch(K[0..n−1], q)'}
                                            <br></br>
                                            {'    minIndex = 0'}
                                            <br></br>
                                            {'    maxIndex = n − 1'}
                                            <br></br>
                                            {'    while maxIndex >= minIndex:'}
                                            <br></br>
                                            {'        midIndex = (minIndex+maxIndex) / 2 // целочисленное деление'}
                                            <br></br>
                                            {'        if K[midIndex] = q:'}
                                            <br></br>
                                            {'            return midIndex'}
                                            <br></br>
                                            {'        else K[midIndex] < q:'}
                                            <br></br>
                                            {'            minIndex = midIndex + 1'}
                                            <br></br>
                                            {'        else:'}
                                            <br></br>
                                            {'            maxIndex = midIndex - 1'}
                                            <br></br>
                                            {'    return -1'}
                                        </code></pre>
                                    </p>
                                    <p>
                                    Например, если q = 9 и K = [1, 3, 7, 8, 9, 12, 15], BinarySearch сначала задаст следующее: 
                                    minIndex = 0, maxIndex = 6 и midIndex = 3. Так как q больше, чем K[midIndex] = 8, мы рассматриваем 
                                    подмассив, элементы которого больше K[midIndex], установив minIndex = 4, и таким образом midIndex 
                                    перевычисляется как (4 + 6)/2 = 5. В этот раз q меньше, чем K[midIndex] = 12, поэтому мы 
                                    рассматриваем подмассив, элементы которого ниже этого значения. Этот подмассив состоит из одного 
                                    элемента — q.
                                    </p>
                                    <p>
                                    Время выполнения BinarySearch составляет O(log n), так как алгоритм снижает длину подмассива минимум 
                                    в два раза при каждой итерации цикла while. Обратите внимание: наша система оценки не может знать, 
                                    использовали вы быстрый алгоритм с трудоёмкостью O(log n) для поиска в отсортированном массиве или 
                                    примитивный алгоритм с трудоёмкостью O(n). Дело в том, что любой программе требуется линейное время 
                                    для чтения данных ввода. По этой причине мы предлагаем вам решить следующую более общую задачу.
                                    </p>
                                    <h3> Множественный поиск ключей в отсортированной последовательности </h3>
                                    <p>
                                        <h6> Вывод: </h6>
                                        При каждом q<sub>i</sub> необходимо проверить, входит ли q<sub>i</sub> в K.
                                        <br></br>
                                        <br></br>
                                        <h6> Формат ввода: </h6>
                                        Отсортированный массив K неповторяющихся целых чисел и массив целых чисел 
                                        Q = [q<sub>0</sub>, ..., q<sub>m - 1</sub>]. Первые две строки ввода содержат целое число n и 
                                        последовательность k<sub>0</sub> {'<'} k<sub>1</sub> {'<'} ... {'<'} k<sub>n - 1</sub> из n 
                                        неповторяющихся положительных целых чисел в возрастающем порядке. Следующие две строки содержат 
                                        целое число m и m положительных целых чисел q<sub>0</sub>, ..., q<sub>m - 1</sub>.
                                        <br></br>
                                        <br></br>
                                        <h6> Формат вывода: </h6>
                                        Для всех i от 0 до m - 1 выведите индекс 0 {'\u{2264}'} j {'\u{2264}'} n - 1, чтобы 
                                        k<sub>j</sub> = q<sub>i</sub> или -1 при отсутствии такого индекса.
                                        <br></br>
                                        <br></br>
                                        <h6> Ограничения: </h6>
                                        1 {'\u{2264}'} n {'\u{2264}'} 3 * 10<sup>4</sup>;
                                        1 {'\u{2264}'} m {'\u{2264}'} 10<sup>5</sup>;
                                        1 {'\u{2264}'} k<sub>i</sub> {'\u{2264}'} 10<sup>9</sup>
                                        для всех
                                        0 {'\u{2264}'} i {'<'} n;
                                        1 {'\u{2264}'} q<sub>j</sub> {'\u{2264}'} 10<sup>9</sup>
                                        для всех
                                        0 {'\u{2264}'} j {'<'} n.
                                        <br></br>
                                        <br></br>
                                        <h6>Примеры:</h6>
                                        <img
                                            className=""    
                                            src={theory_8_pic_4}
                                            alt="theory_8_pic_4"
                                            width={250}
                                        />
                                        <img
                                            className=""
                                            src={theory_8_pic_5}
                                            alt="theory_8_pic_5"
                                            width={250}
                                        />
                                        <br></br>
                                        <br></br>
                                        <h6> Совет: </h6>
                                        Не используйте встроенный двоичный поиск.
                                    </p>

                                    <h3> Двоичный поиск с дублированием </h3>
                                    <p>
                                    Как пишет автор книги "Искусство программирования" Дональд Кнут: "Хотя основная идея двоичного 
                                    поиска относительно проста, детали могут быть на удивление сложными". Он подразумевает изменённую 
                                    версию классической задачи двоичного поиска:
                                    </p>
                                    <p>
                                    Когда Кнут попросил профессиональных программистов из таких ведущих компаний, как IBM, реализовать 
                                    эффективный алгоритм двоичного поиска с дублированием, в 90% из них были баги — год за годом. 
                                    И правда, хотя первый алгоритм двоичного поиска был опубликован в 1946 году, первый алгоритм для 
                                    поиска с дублированием, в котором не было багов, впервые опубликовали только в 1962 году.
                                    </p>
                                    <p>
                                        По аналогии с предыдущей задачей здесь мы предлагаем найти m целых чисел, а не одно.
                                        <br></br>
                                        <br></br>
                                        <h6> Формат ввода: </h6>
                                        Первые две строки ввода содержат целое число n и последовательность k<sub>0</sub> {'\u{2264}'} 
                                        k<sub>1</sub> {'\u{2264}'} ... {'\u{2264}'} k<sub>n - 1</sub> из n положительных целых чисел в 
                                        неубывающем порядке. Следующие две строки содержат целое число m и m положительных целых чисел 
                                        q<sub>0</sub>, q<sub>1</sub>, ..., q<sub>m - 1</sub>.
                                        <br></br>
                                        <br></br>
                                        <h6> Формат вывода: </h6>
                                        Для всех i от 0 до m - 1 вывод индекса 0 {'\u{2264}'} j {'\u{2264}'} n - 1 первого встречающегося 
                                        q<sub>i</sub> (то есть k<sub>j</sub> = q<sub>i</sub>) или -1 — если такого индекса нет.
                                        <br></br>
                                        <br></br>
                                        <h6> Ограничения: </h6>
                                        1 {'\u{2264}'} n {'\u{2264}'} 3 * 10<sup>4</sup>;
                                        1 {'\u{2264}'} m {'\u{2264}'} 10<sup>5</sup>;
                                        1 {'\u{2264}'} k<sub>i</sub> {'\u{2264}'} 10<sup>9</sup>
                                        для всех
                                        0 {'\u{2264}'} i {'<'} n;
                                        1 {'\u{2264}'} q<sub>j</sub> {'\u{2264}'} 10<sup>9</sup>.
                                        для всех
                                        1 {'\u{2264}'} j {'<'} m;
                                        <br></br>
                                        <br></br>
                                        <h6>Примеры:</h6>
                                        <img
                                            className=""
                                            src={theory_8_pic_6}
                                            alt="theory_8_pic_6"
                                            width={250}
                                        />
                                        <img
                                            className=""
                                            src={theory_8_pic_7}
                                            alt="theory_8_pic_7"
                                            width={250}
                                        />
                                        <h6> Ограничения: </h6>
                                        Не используйте встроенный двоичный поиск.
                                    </p>
                                    <h6> Решение </h6>
                                    <p>
                                    У вас есть ключ q и вам необходимо найти первое, самое раннее место, где этот ключ встречается в 
                                    массиве K. Например, если K = 3, 6, 6, 7, 7, 7, 7, 9 и ключ q — это 7, тогда первое место, где он 
                                    встречается, — это индекс 3. Разумеется, вы можете найти одно из мест, просто начав двоичный поиск. 
                                    Чтобы найти первое место, где ключ встречается, вы можете последовательно проверять элемент перед 
                                    позицией того, который был найден, — что и демонстрируется в выделенных голубым строках 
                                    приведенного ниже псевдокода.
                                    </p>
                                    <p>
                                        <pre><code>
                                            {'NaiveBinarySearchWithDuplicates(K[0..n−1], q)'}
                                            <br></br>
                                            {'    minIndex = 0'}
                                            <br></br>
                                            {'    maxIndex = n − 1'}
                                            <br></br>
                                            {'    while maxIndex >= minIndex:'}
                                            <br></br>
                                            {'        midIndex = (minIndex + maxIndex) / 2'}
                                            <br></br>
                                            {'        if K[midIndex] = q:'}
                                            <br></br>
                                            {'            top = midIndex'}
                                            <br></br>
                                            {'            while top > 0 and K[top − 1] = K[top]:'}
                                            <br></br>
                                            {'                top = top - 1'}
                                            <br></br>
                                            {'            return top'}
                                            <br></br>
                                            {'        if K[midIndex] < q:'}
                                            <br></br>
                                            {'            minIndex = midIndex + 1'}
                                            <br></br>
                                            {'        else:'}
                                            <br></br>
                                            {'            maxIndex = midIndex - 1'}
                                            <br></br>
                                            {'    return -1'}
                                        </code></pre>
                                    </p>
                                    <p>
                                        <i> 
                                            Остановитесь и подумайте:
                                            Каково время выполнения этого алгоритма?
                                        </i>
                                    </p>
                                    <p>
                                    Этот алгоритм может существенно замедлиться при массиве с большим количеством повторов. Например, 
                                    если повторяющийся элемент занимает половину массива, то NaiveBinarySearchWithDuplicates потребует 
                                    линейное время O(n) вместо логарифмического времени O(log n). Эта проблема устранена в псевдокоде ниже.
                                    </p>
                                    <p>
                                        <pre><code>
                                            {'NaiveBinarySearchWithDuplicates(K[0..n−1], q)'}
                                            <br></br>
                                            {'    minIndex = 0'}
                                            <br></br>
                                            {'    maxIndex = n − 1'}
                                            <br></br>
                                            {'    result = -1'}
                                            <br></br>
                                            {'    while maxIndex >= minIndex:'}
                                            <br></br>
                                            {'        midIndex = (minIndex + maxIndex) / 2'}
                                            <br></br>
                                            {'        if K[midIndex] = q:'}
                                            <br></br>
                                            {'            maxIndex = midIndex - 1'}
                                            <br></br>
                                            {'            result = midIndex'}
                                            <br></br>
                                            {'            while top > 0 and K[top − 1] = K[top]:'}
                                            <br></br>
                                            {'                top = top - 1'}
                                            <br></br>
                                            {'            return top'}
                                            <br></br>
                                            {'        if K[midIndex] < q:'}
                                            <br></br>
                                            {'            minIndex = midIndex + 1'}
                                            <br></br>
                                            {'        else:'}
                                            <br></br>
                                            {'            maxIndex = midIndex - 1'}
                                            <br></br>
                                            {'    return result'}
                                        </code></pre>
                                    </p>
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_9">
                                    <h1> Принципы построения алгоритмов </h1>
                                    <br></br>
                                    <p>
                                    В этом параграфе мы реализуем разные алгоритмы динамического программирования и увидим, как они 
                                    решают задачи, которые не поддавались решению с использованием "жадных" алгоритмов и подхода 
                                    "разделяй и властвуй". Динамическое программирование на практике применяется в большом числе 
                                    случаев. Оно подходит и для поиска похожих страниц в интернете, и для предсказывания генов в 
                                    последовательностях ДНК.
                                    </p>
                                    <p>
                                    В итоге вы узнаете, как одна идея позволяет автоматически исправлять орфографические ошибки и при 
                                    этом находить разницу между двумя вариантами одного и того же текста.
                                    </p>
                                    <h3> Основная идея </h3>
                                    <br></br>
                                    <h5> Количество путей </h5>
                                    <p>
                                    Для понимания идеи, которая используется в подходе динамического программирования, предлагаем вам 
                                    попробовать решить следующую головоломку.
                                    </p>
                                    <h6>Интерактивная головоломка "Количество путей"</h6>
                                    <p>
                                    В нижеприведённой сети есть множество путей ведущих от s к t, — например: s {'\u{2192}'} b 
                                    {'\u{2192}'} e {'\u{2192}'} t и s {'\u{2192}'} a {'\u{2192}'} c {'\u{2192}'} d 
                                    {'\u{2192}'} t. Каково общее количество путей?
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_9_pic_1}
                                        alt="theory_9_pic_1"
                                        width={500}
                                    />
                                    <p>
                                    Так как мы начинаем с s, существует уникальный способ добраться до s. Давайте запишем:
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_9_pic_2}
                                        alt="theory_9_pic_2"
                                        width={500}
                                    />
                                    <p>
                                    Для a и b также существует просто один путь.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_9_pic_3}
                                        alt="theory_9_pic_3"
                                        width={500}
                                    />
                                    <p>
                                    Так как существует только один путь к a и только один к b, количество путей к c составляет 1 + 1 = 2 
                                    (s {'\u{2192}'} a {'\u{2192}'} c и s {'\u{2192}'} b {'\u{2192}'} c).
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_9_pic_4}
                                        alt="theory_9_pic_4"
                                        width={500}
                                    />
                                    <p>
                                    Аналогичным образом для достижения d необходимо прийти либо к a, либо к c. Существует только один 
                                    путь до a и два пути до c. Так количество путей, которые ведут к d, составляет 1 + 2 = 3 
                                    (s {'\u{2192}'} a {'\u{2192}'} d, s {'\u{2192}'} a {'\u{2192}'} c {'\u{2192}'} d 
                                    и s {'\u{2192}'} b {'\u{2192}'} c {'\u{2192}'} d).
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_9_pic_5}
                                        alt="theory_9_pic_5"
                                        width={500}
                                    />
                                    <p>
                                    Количество путей, заканчивающихся на e, равно 1, так как к e можно прийти только от b.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_9_pic_6}
                                        alt="theory_9_pic_6"
                                        width={500}
                                    />
                                    <p>
                                    До c есть два пути, до d — три пути, до e — один. Выходит, что путей до t существует 2 + 3 + 1 = 6.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_9_pic_7}
                                        alt="theory_9_pic_7"
                                        width={500}
                                    />
                                    <h5> Динамическое программирование </h5>
                                    <p>
                                    Рассмотрим наше решение головоломки "Количество путей" и изложим основные идеи динамического 
                                    программирования. Для узла v — paths(v) будет количеством путей от стартового узла s к узлу v. 
                                    Несомненно, paths(s) = 1. Это называется базовый случай. Соответствующее значение для всех других 
                                    узлов можно найти с помощью рекуррентного соотношения paths(v) = {'\u2211'} paths(w) для всех 
                                    предшествующих w от v, где предшественник v — это узел, связанный ребром с v.
                                    </p>
                                    <p>
                                    Многие алгоритмы динамического программирования используют одну схему:
                                    <br></br> 
                                    - Вместо того, чтобы решать изначальную задачу, алгоритм решает несколько подзадач такого же типа.
                                    <br></br> 
                                    - Алгоритм вычисляет решение для каждой подзадачи с помощью рекуррентного соотношения, в которое 
                                    входят решения более мелких подзадач.
                                    <br></br>
                                    - Алгоритм сохраняет решения подзадач и таким образом избегает перевычисления.
                                    </p>
                                    <h5> Ориентированный ациклический граф: кратчайший путь </h5>
                                    <p>
                                    Теперь рассмотрим взвешенный граф, в котором у каждого ребра e обозначена длина length(e). 
                                    Длина пути в таком графе определяется суммой длины рёбер.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_9_pic_8}
                                        alt="theory_9_pic_8"
                                        width={500}
                                    />
                                    <p>
                                    Например, длина пути s {'\u{2192}'} b {'\u{2192}'} e {'\u{2192}'} t составляет 5 + 7 + 4 = 16. 
                                    Какова минимальная длина пути от s до t?
                                    </p>
                                    <p>
                                    Так как каждый путь от s до t проходит через c, d или e перед тем, как прийти к t, 
                                    {'length(t) = min\{length(c) + 6, length(d) + 8, length(e) + 4\}'}, где length(v) — минимальная 
                                    длина пути от s до v. Расстояния до c, d и e можно найти с помощью похожих рекуррентных соотношений:
                                    <br></br>
                                    {'length(c) = min\{length(a) + 4, length(b) + 1\}'}
                                    <br></br>
                                    {'length(d) = min\{length(a) + 7, length(c) + 2\}'}
                                    <br></br>
                                    {'length(e) = length(b) + 7'}
                                    </p>
                                    <p>
                                    Приведём рекуррентные соотношения для a и b:
                                    <br></br>
                                    {'length(a) = length(s) + 4'}
                                    <br></br>
                                    {'length(b) = length(s) + 5'}
                                    </p>
                                    <p>
                                    Наконец, базовый случай — это length(s) = 0. С его помощью можно найти расстояние до всех узлов 
                                    сети, включая наш узел t. Для этого нужно использовать вышеприведённые рекуррентные соотношения, 
                                    которые можно записать в компактной форме: length(v) = min(length(w) + length(w, v)) для всех 
                                    предшествующих w от v.
                                    </p>
                                    <p>
                                    Для модельной ситуации удобно записывать результаты по мере того, как мы выполняем вычисления, 
                                    прямо на изображении. Мы получаем следующие результаты.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_9_pic_9}
                                        alt="theory_9_pic_9"
                                        width={500}
                                    />
                                    <p>
                                        <i> 
                                            Остановитесь и подумайте:
                                            Минимальная длина пути от s до t составляет 12. Можете понять, как находится путь такой длины?
                                        </i>
                                    </p>
                                    <p>
                                    В алгоритме динамического программирования для этого выполняется бэктрекинг ("поиск с возвратом") 
                                    решений, которые привели к оптимальному результату. В особенности отметим один из трёх выборов, 
                                    который приводит нас к значению length(t).
                                    </p>
                                    <p>
                                    {'length(t) = min\{length(c) + 6, length(d) + 8, length(e) + 4\} = min\{12, 16, 16\} = 12'}
                                    </p>
                                    <p>
                                    Исходя из этого, мы можем заключить, что последнее ребро оптимального пути — это c {'\u{2192}'} t. 
                                    Аналогично, {'length(c) = min\{length(a) + 4, length(b) + 1\} = min\{8, 6\} = 6'}. Так мы приходим 
                                    от b к c. Таким образом, путь от s до t длиной 12 составляет s {'\u{2192}'} b {'\u{2192}'} c 
                                    {'\u{2192}'} t.
                                    </p>
                                    <p>
                                    У вышеприведённой сети есть удобное свойство. Оно заключается в том, что мы можем определять порядок 
                                    её узлов, что обеспечивает следующее: каждый узел идет после всех предшествующих — то есть узлы, 
                                    которые указывают на текущий узел (например, c, d и e предшествуют t). Сети с таким свойством 
                                    называются ориентированные ациклические графы. Мы увидим, что многие алгоритмы динамического 
                                    программирования используют ориентированные ациклические графы — явно или неявно.
                                    </p>
                                    <h3> Проектирование алгоритмов динамического программирования </h3>
                                    <p>
                                    Теперь, когда вы познакомились с несколькими алгоритмами динамического программирования, подведём 
                                    итог и повторим основные шаги для проектирования таких алгоритмов.
                                    </p>
                                    <h6> Определить подпроблемы </h6>
                                    <p>
                                    Первый и самый важный шаг — это идентифицировать подпроблемы и записать рекуррентное соотношение 
                                    (с базовым случаем). Как правило, это делается через анализ структуры оптимального решения или 
                                    через оптимизацию решения, использующего исчерпывающий поиск.
                                    </p>
                                    <h6> Спроектировать рекурсивный алгоритм </h6>
                                    <p>
                                    Сделать из рекуррентного соотношения рекурсивный алгоритм: — сохранить решение каждой подзадачи в 
                                    таблице; — перед решением подзадачи проверить, нет ли уже в таблице её решения (мемоизация).
                                    </p>
                                    <h6> Спроектировать итерационный алгоритм </h6>
                                    <p>
                                    Сделать из рекурсивного алгоритма итерационный алгоритм: — инициализировать таблицу; — продвигаться от мелких подзадач к большим.
                                    </p>
                                    <h6> Оценить время выполнения </h6>
                                    <p>
                                    Доказать верхнее ограничение времени выполнения. Обычно произведение количества подпроблем и времени, 
                                    необходимого для решения подзадачи, предоставляет верхнее ограничение времени выполнения.
                                    </p>
                                    <h6> Обнаружить решение </h6>
                                    <p>
                                    Обнаружить оптимальное решение, используя бэктрекинг рекуррентного соотношения.
                                    </p>
                                    <h6> Экономить место </h6>
                                    <p>
                                    Использовать обычную структуру таблицы, чтобы проверить, можно ли сэкономить место по сравнению 
                                    с более прямым решением.
                                    </p>
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_10">
                                    <h1> Односвязный список </h1>
                                    <br></br>
                                    <p>
                                    Односвязный список (иногда "связный список") — базовая структура данных, представляющая собой 
                                    соединённые узлы с однотипными данными. Каждый узел состоит из элемента и ссылки на следующий 
                                    элемент (см. рисунок).
                                    </p>
                                    <p>
                                    Самый первый элемент списка называют головой (head) односвязного списка, а последний — хвостом 
                                    (tail). Последний элемент односвязного списка в качестве ссылки содержит null-значение.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_10_pic_1}
                                        alt="theory_10_pic_1"
                                        width={500}
                                    />
                                    <p>
                                        <i> 
                                            Остановитесь и подумайте:
                                            Какие достоинства и недостатки по сравнению с обычным массивом у односвязного списка?
                                        </i>
                                    </p>
                                    <p>
                                    В отличие от классического массива, где данные в памяти расположены строго последовательно, в 
                                    односвязном списке, наоборот, данные расположены хаотично и связывание узлов списка происходит 
                                    посредством ссылок. За счёт этой особенности в односвязный список можно добавлять произвольное 
                                    число элементов, однако, доступ будет осуществляться только последовательно. Произвольного доступа 
                                    к элементам в односвязном списке нет.
                                    </p>
                                    <p>
                                    Со списком можно производить ряд операций:
                                    <br></br>
                                    - Добавить элемент (add)
                                    <br></br>
                                    - Удалить элемент (remove)
                                    <br></br>
                                    - Найти элемент (find)
                                    <br></br>
                                    - Посчитать количество элементов по условию (count)
                                    </p>
                                    <p>
                                    Операция добавления элемента (add) может быть представлена в нескольких вариантах. Элемент можно 
                                    добавить в начало списка, можно добавить в конец списка или после определённого элемента. Перед 
                                    добавлением элемента необходимо создать узел, положив в него заданное значение, затем связать 
                                    ссылку со списком. В случае добавления в начало списка ссылка нового узла будет указывать на голову 
                                    списка, а голова списка должна быть перемещена на новый узел. Если добавление идёт в конце списка, 
                                    то ссылка хвоста списка должна указывать на новый узел, а после должна быть перемещена на новый 
                                    узел. Сложность этих операций — O(1).
                                    </p>
                                    <p>
                                    Удаление элемента (remove) предполагает, что будет найден заданный элемент и следом он будет удалён. 
                                    Нахождения узла требует прохода по односвязному списку, после чего необходимо ссылку с элемента 
                                    перед удаляемым перенаправить на элемент после удаляемого. Сложность операции — O(n), где n — число 
                                    элементов в списке.
                                    </p>
                                    <p>
                                    Нахождение элемента (find) предполагает простой однократный проход по списку с нахождением ссылки на 
                                    заданный элемент. Сложность операции — O(n), где n — число элементов в списке.
                                    </p>
                                    <p>
                                    Подсчёт числа элементов по условию (count) предполагает проход по списку и сравнение всех элементов 
                                    с заданным с подсчётом количества удовлетворяющих условию элементов. Сложность операции — O(n), где 
                                    n — число элементов в списке.
                                    </p>
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_11">
                                    <h1> Множество </h1>
                                    <br></br>
                                    <p>
                                    Следующей структурой данных, которую мы рассмотрим, будет множество (set). Множество представляет 
                                    собой контейнер, содержащий неповторяющиеся элементы в произвольном порядке. Обратите внимание, в 
                                    стандартной библиотеке С++ реализовано упорядоченное множество, что накладывает свои особенности на 
                                    вычислительную сложность некоторых операций. Далее в данном параграфе мы будем разграничивать 
                                    упорядоченные и неупорядоченные множества.
                                    </p>
                                    <p>
                                    Кроме того, существует такое понятие, как мультимножество (multiset), которое может включать в себя 
                                    несколько одинаковых элементов.
                                    </p>
                                    <p>
                                    Вы можете посмотреть на различия между множеством и мультимножеством на рисунке ниже.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_11_pic_1}
                                        alt="theory_11_pic_1"
                                        width={500}
                                    />
                                    <p>
                                    Внутренняя реализация множества осуществляется различными способами, включая использование 
                                    хэш-таблицы, бинарного дерева поиска и других алгоритмов. В данном параграфе мы сосредоточимся на 
                                    функциях, которые можно производить со множеством, а не на внутренней его реализации.
                                    </p>
                                    <p>
                                    Основные операции со множеством:
                                    <br></br>
                                    - Добавление элемента в множество
                                    <br></br>
                                    - Удаление элемента из множества
                                    <br></br>
                                    - Проверка наличия элемента в множестве
                                    <br></br>
                                    - Объединение двух множеств
                                    <br></br>
                                    - Пересечение двух множеств
                                    <br></br>
                                    - Разность двух множеств
                                    </p>
                                    <p>
                                    Рассмотрим основные операции с неупорядоченным множеством в Python.
                                    </p>
                                    <p>
                                        Добавление элемента в множество можно произвести следующим образом.
                                        <pre><code>
                                            {'my_set = {1, 2, 3}'}
                                            <br></br>
                                            {'my_set.add(2)'}
                                            <br></br>
                                            {'print(my_set)'}
                                            <br></br>
                                            {'my_set.add(4)'}
                                            <br></br>
                                            {'print(my_set)'}
                                        </code></pre>
                                        В результате исполнения фрагмента кода выше на экран будет выведено две строки: 1 2 3 и 1 2 3 4. 
                                        Сложность операции добавления элемента во множество в Python — O(1), так как множество не упорядочено 
                                        и не нужно искать позиции для его вставки.
                                    </p>
                                    <p>
                                        Рассмотрим удаление элемента из множества в Python:
                                        <pre><code>
                                            {'my_set = {1, 2, 3}'}
                                            <br></br>
                                            {'my_set.remove(1)'}
                                            <br></br>
                                            {'print(len(my_set))'}
                                        </code></pre>
                                        Размер множества после удаления элемента становится равным двум. Сложность операции удаления в 
                                        неупорядоченном множестве — O(1).
                                    </p>
                                    <p>
                                    Проверка наличия элемента в множестве предполагает просмотр элементов в нём. В случае 
                                    неупорядоченного множества, реализованного на хэш-таблицах, сложность — О(1). Однако, при 
                                    использовании упорядоченного множества сложность становится O(log n).
                                    </p>
                                    <p>
                                    Объединение множеств предполагает их слияние в единое множество. Например, пусть было два множества. 
                                    Первое содержало элементы 1, 2 и 3, а второе 2, 3 и 4. В результате объединения получится множество, 
                                    содержащее четыре элемента 1, 2, 3 и 4.
                                    </p>
                                    <p>
                                    Пересечение множеств представляет из себя поиск в двух множествах одинаковых элементов. Пусть первое 
                                    множество содержит элементы 1, 2 и 3, а второе — 2, 3 и 4. Тогда пересечением множеств будут 
                                    являться элементы 2 и 3.
                                    </p>
                                    <p>
                                    Разность двух множеств предполагает нахождение всех элементов из первого множества, за исключением 
                                    тех, которые находятся во втором множестве. Пусть первое множество содержит элементы 1, 2 и 3, а 
                                    второе — 2, 3 и 4. Тогда разностью множеств будет элемент 1.
                                    </p>
                                    <p>
                                        <i> 
                                        Упражнение:
                                        Поработайте с двумя множествами {'А = \{1, 3, 4, 5, 6\}'}, {'B = \{1, 2, 4, 6, 8, 9\}'}. 
                                        Для данных множеств найдите объединение, пересечение и разность.
                                        </i>
                                    </p>
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_12">
                                    <h1> Словарь </h1>
                                    <br></br>
                                    <p>
                                    Следующей структурой данных, которую мы рассмотрим, будет словарь (map, dictionary) или, так 
                                    называемый ассоциативный массив, позволяющий хранить пары вида "ключ — значение". Ключ — уникальный 
                                    идентификатор, а значение может быть любой объектной переменной, включая другие структуры данных. 
                                    Например, списки или другие словари. Ключи и значения могут выводиться в различном порядке, потому 
                                    что словари не упорядочены.
                                    </p>
                                    <p>
                                    Аналогично множеству, у словаря существует мультисловарь (multimap), который позволяет хранить 
                                    несколько элементов с одинаковым ключом. Посмотрите на примеры ниже.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_12_pic_1}
                                        alt="theory_12_pic_1"
                                        width={500}
                                    />
                                    <p>
                                    Довольно часто словари реализуют с использованием хэш-таблиц. Говоря об асимптотической сложности 
                                    операций со словарем, будем иметь ввиду реализацию на хэш-таблицах.
                                    </p>
                                    <p>
                                        Основные операции со словарем и их асимптотическая сложность:
                                        <br></br>
                                        - Добавление нового элемента с уникальным ключом — O(1)
                                        <br></br>
                                        - Удаление элемента по ключу — O(1)
                                        <br></br>
                                        - Изменение значения по ключу — O(1)
                                        <br></br>
                                        - Получение значения по ключу — O(1)
                                    </p>
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_13">
                                    <h1> Стек </h1>
                                    <br></br>
                                    <p>
                                    Стек (stack) — структура данных, которая работает по принципу "последним пришёл, первым ушёл" 
                                    (LIFO — last in, first out). Стек можно представить как некий контейнер, в котором элементы 
                                    (например, числа, символы и так далее) могут быть добавлены в вершину, а затем извлечены только из 
                                    вершины. В бытовом плане стек напоминает стопку тарелок. Тогда тарелка, которую положили первой, в 
                                    самый низ, будет использована последней.
                                    </p>
                                    <p>
                                    Существуют различные реализации стека. Например, стек может быть реализован на массиве, на 
                                    односвязном списке, на двусвязном списке и так далее. В параграфе будем говорить о реализации 
                                    стека на односвязном списке.
                                    </p>
                                    <p>
                                        Основные операции, которые можно производить со стеком, включают:
                                        <br></br>
                                        - Добавление элемента в вершину стека (push) — O(1)
                                        <br></br>
                                        - Удаление элемента из вершины стека (pop) — O(1)
                                        <br></br>
                                        - Возврат верхнего элемента без его удаления (peek) — O(1)
                                        <br></br>
                                        - Проверка стека на пустоту (isEmpty) — O(1)
                                    </p>
                                    <p>
                                    Стоит отметить, что стек представляет собой список с элементами и указателя на вершину стека, 
                                    указывающего на последний элемент, добавленный в стек.
                                    </p>
                                    <p>
                                    Каждый раз, когда в стек добавляется новый элемент, указатель на вершину смещается на следующий 
                                    элемент. Когда элемент удаляется из вершины стека, указатель смещается на предыдущий элемент. 
                                    Если указатель находится в конце стека, то стек пуст.
                                    </p>
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_14">
                                    <h1> Очередь с приоритетом </h1>
                                    <br></br>
                                    <p>
                                    Очередь с приоритетом — коллекция элементов, где каждый элемент имеет связанный с ним приоритет. 
                                    Элемент с высшим приоритетом будет обрабатываться раньше, чем элементы с более низким приоритетом.
                                    </p>
                                    <p>
                                        Очередь с приоритетом можно реализовать различными способами, но обычно главные операции над ними:
                                        <br></br>
                                        - <i>Вставка элемента с приоритетом</i> — добавление элемента в очередь с учётом его приоритета. 
                                        В зависимости от реализации, элемент может быть добавлен в начало, в середину очереди или конец.
                                        <br></br>
                                        - <i>Извлечение элемента с наивысшим приоритетом</i> — удаление элемента из очереди с наивысшим приоритетом. 
                                        В зависимости от реализации, удаление может происходить из начала, середины очереди или конца.
                                        <br></br>
                                        - <i>Просмотр элемента с наивысшим приоритетом</i> — просмотр элемента с наивысшим приоритетом 
                                        без его удаления.
                                        <br></br>
                                        - <i>Поиск элемента с определенным приоритетом</i> — поиск элемента в очереди с опредёленным приоритетом.
                                    </p>
                                    <p>
                                    Основные способы реализации очереди с приоритетом включают в себя использование массивов, связанных 
                                    списков, бинарных куч и древовидных структур. В зависимости от реализации, каждый из этих способов 
                                    имеет свои преимущества и недостатки в терминах времени выполнения операций.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_14_pic_1}
                                        alt="theory_14_pic_1"
                                        width={500}
                                    />
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_15">
                                    <h1> Дек </h1>
                                    <br></br>
                                    <p>
                                    Дек (deque, double-ended queue) — универсальная структура данных, которая представляет собой 
                                    последовательность элементов, у которой есть два конца. Причём добавление и удаление элементов 
                                    может происходить как в начало, так и в конец структуры.
                                    </p>
                                    <p>
                                        Структура дек обладает следующими особенностями:
                                        <br></br>
                                        - Вставка элемента возможна как в начало, так и в конец
                                        <br></br>
                                        - Удаление элемента так же возможно как в начале, так и в конце
                                        <br></br>
                                        - Доступ к первому и последнему элементу производится за константное время O(1)
                                        <br></br>
                                        - Доступ к элементам в середине дека осуществляется за линейное время O(n), так как элементы 
                                        хранятся последовательно
                                    </p>    
                                    <p>
                                    В целом, дек представляет собой смесь стека и очереди.
                                    </p>
                                    <p>
                                    Структура дек может реализовываться различными способами, например, с использованием двух стэков 
                                    или двусвязного списка.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_15_pic_1}
                                        alt="theory_15_pic_1"
                                        width={500}
                                    />
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_16">
                                    <h1> Природа графа </h1>
                                    <br></br>
                                    <p>
                                    В данном параграфе мы разберём основные понятия и определения теории графов — раздела математики, 
                                    который изучает графы, их природу, структуры и алгоритмы. Также посмотрим, где можно встретить 
                                    графы в реальной жизни.
                                    </p>
                                    <p>
                                    Граф состоит из множества вершин, соединённых ребрами. По сути, рёбра и вершины — базовые понятия. 
                                    Обычно граф обозначают G(V, E), где V — множество вершин, E — множество рёбер/дуг. Проведём аналогию 
                                    с картой метро, которую можно рассматривать как граф, где станции — вершины, а перегоны — рёбра. 
                                    Другим примером может служить обычная карта, где населенные пункты — вершины графа, а рёбра — 
                                    соединяющие их дороги. Генеалогические деревья, блок-схемы, схемы авиалиний и железных дорог — всё 
                                    это примеры графов.
                                    </p>
                                    <p>
                                    Рёбра и вершины графа могут иметь свои имена. Посмотрим на пример графа на рисунке ниже.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_16_pic_1}
                                        alt="theory_16_pic_1"
                                        width={400}
                                    />
                                    <p>
                                    Граф может быть ориентированным или неориентированным. В неориентированном графе рёбра не имеют 
                                    направления, то есть движение по ним возможно в двух направлениях. В ориентированном графе рёбра 
                                    обычно называют дугами. Пройти по дуге можно только в заданном направлении. Пример ориентированного 
                                    графа приведён на рисунке ниже. В дальнейшем под понятием граф мы будем понимать именно 
                                    неориентированный граф.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_16_pic_2}
                                        alt="theory_16_pic_2"
                                        width={500}
                                    />
                                    <p>
                                    В графе могут быть рёбра и дуги особого типа, которые входят и выходят из одной вершины. 
                                    Такие рёбра и дуги называются петлями.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_16_pic_3}
                                        alt="theory_16_pic_3"
                                        width={250}
                                    />
                                    <p>
                                    Между рёбрами и вершинами в графах существуют отношения смежности и инцидентности. Термин смежность 
                                    применяется к объектам одного вида — смежными между собой могут быть вершины и рёбра. Одна вершина 
                                    смежна другой, если они соединены дугой или ребром. Одно ребро смежно другому ребру, если у них 
                                    есть общая вершина, из которой они выходят.
                                    </p>
                                    <p>
                                    Понятие инцидентности применяется к рёбрам и вершинам. Ребро инцидентно вершине, если это ребро 
                                    выходит из вершины.
                                    </p>
                                    <p>
                                    Помимо обычных графов, существуют ещё графы особого вида. Например, мультиграф — граф, у которого 
                                    может быть несколько кратных рёбер или дуг. Пример ориентированного и неориентированного 
                                    мультиграфа приведён на рисунке ниже.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_16_pic_4}
                                        alt="theory_16_pic_4"
                                        width={300}
                                    />
                                    <p>
                                    Рёбрам графа, при необходимости, можно задать веса. В таком случае граф становится взвешенным или 
                                    нагруженным. В качестве веса может выступать, например, расстояние между городами. На рисунке ниже 
                                    показан пример взвешенного графа.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_16_pic_5}
                                        alt="theory_16_pic_5"
                                        width={300}
                                    />
                                    <p>
                                    В рамках данного параграфа нам также понадобится знать определение двудольного графа. Как следует из 
                                    названия, граф состоит из двух долей, в каждой из которых вершины не смежны. На рисунке ниже можно 
                                    увидеть, что вершины 1, 2 и 3 принадлежат одной доле, а вершины 4 и 5 другой.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_16_pic_6}
                                        alt="theory_16_pic_6"
                                        width={500}
                                    />
                                    <p>
                                    Как вы думаете, а может ли граф вообще не содержать ребер? Да, такое бывает. В этом случае говорят 
                                    о нуль-графе.
                                    </p>
                                    <p>
                                    А может быть и обратная ситуация, когда граф содержит все возможные ребра или дуги. Такие графы 
                                    называются полными. Посмотрите на пример полного графа ниже.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_16_pic_7}
                                        alt="theory_16_pic_7"
                                        width={400}
                                    />
                                    <p>
                                        <i> 
                                            Остановитесь и подумайте:
                                            Сколько рёбер может быть в полном неориентированном графе? А в ориентированном?
                                        </i>
                                    </p>
                                    <p>
                                    Двудольный граф также может быть полным. Полный двудольный граф — граф, содержащий все возможные 
                                    рёбра или дуги. Пример полного двудольного графа изображён ниже.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_16_pic_8}
                                        alt="theory_16_pic_8"
                                        width={300}
                                    />
                                    <p>
                                    В графе можно построить путь — последовательность связанных рёбер, которые соединяют вершины графа. 
                                    Цикл — путь, который начинается и заканчивается в одной и той же вершине.
                                    </p>
                                    <p>
                                    А может ли в графе отсутствовать цикл? Да, может, и в этом случае речь о таком графе как дерево. 
                                    Дерево — граф без циклов.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_16_pic_9}
                                        alt="theory_16_pic_9"
                                        width={300}
                                    />
                                    <p>
                                    Графы могут быть связными и не связными. Связный граф тот, в котором от всех вершин до каждой 
                                    существует путь. Пример несвязного графа приведён на рисунке ниже.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_16_pic_10}
                                        alt="theory_16_pic_10"
                                        width={500}
                                    />
                                    <p>
                                        При этом в ориентированном графе говорят о сильной и слабой связности. Ориентированный граф называется:
                                        <br></br>
                                        - слабо связным - если его неориентированный аналог является связным;
                                        <br></br>
                                        - сильно связным - если всякая вершина v достижима из любой вершины u.
                                    </p>
                                    <p>
                                    Очевидно, что любой сильно связный граф, также является и слабо связным.
                                    </p>
                                    <p>
                                    Важно отметить, что графы имеют свои характеристики. Например, для вершин графа существует понятие 
                                    степени. Степень вершины — число инцидентных этой вершине рёбер. Обычно степень вершины обозначают 
                                    функцией d(v). На рисунке ниже, d(1) = 1, d(2) = 3, d(3) = 2, d(4) = 2.
                                    </p>
                                    <p align="center">
                                        <i>Несвязный граф G</i>
                                        <br></br>
                                        <br></br>
                                        <img
                                            className="d-block m-auto"
                                            src={theory_16_pic_11}
                                            alt="theory_16_pic_11"
                                            width={400}
                                        />
                                    </p>
                                    <p>
                                    В ориентированном графе говорят про полустепени исхода и захода. Под полустепенью исхода понимается 
                                    количество дуг, выходящих из вершины. Под полустепенью захода понимают число дуг, заходящих в 
                                    вершину. Обычно, полустепень исхода обозначают d - (v), а полустепень захода — d + (v).
                                    </p>
                                    <p>
                                    Если речь про петли, то в случае неориентированного графа она учитывается как два ребра, а в случае 
                                    ориентированного для вершины эта дуга учитывается и в полустепени исхода, и в полустепени захода.
                                    </p>
                                    <p>
                                        <i> 
                                        Упражнение:
                                        Для ориентированного графа, изображенного на рисунке 2 посчитайте полустепени исхода и захода.
                                        </i>
                                    </p>
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_17">
                                    <h1> Представление графа в памяти компьютера </h1>
                                    <br></br>
                                    <p>
                                    В прошлом параграфе мы обсудили основные определения теории графов. Однако, чтобы работать с графами, 
                                    необходимо их как-то хранить в памяти компьютера. К сожалению, не существует универсального способа 
                                    хранения графов, потому что каждый имеет свои достоинства и недостатки.
                                    </p>
                                    <p>
                                    Рассмотрим такой способ хранения графа, как матрица смежности. Матрица смежности представляет собой 
                                    матрицу, где по строкам и столбцам располагаются номера вершин. Если рёбра между вершинами 
                                    отсутствует, то на пересечении i-ой строки и j-ого столбца ставится 0. Если ребро есть, то ставят 1. 
                                    Пример графа и его матрицы смежности приведён на рисунке ниже.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_17_pic_1}
                                        alt="theory_17_pic_1"
                                        width={450}
                                    />
                                    <p>
                                        <i> 
                                        Остановитесь и подумайте:
                                        Всегда ли матрица смежности для неориентированного графа симметрична?
                                        </i>
                                    </p>
                                    <p>
                                    Рассмотрим пример матрицы смежности для ориентированного графа. В целом, отличий не так много, кроме 
                                    того, что матрица смежности перестала быть симметричной. Подумайте, почему.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_17_pic_2}
                                        alt="theory_17_pic_2"
                                        width={500}
                                    />
                                    <p>
                                    Также при работе с графами применяется и матрица инцидентности. По столбцам располагаются рёбра, а 
                                    по строкам номера вершин. На пересечении i-ой вершины и j-ого ребра ставится 1, если одним из концов 
                                    ребра j была вершина i. Пример приведён ниже.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_17_pic_3}
                                        alt="theory_17_pic_3"
                                        width={450}
                                    />
                                    <p>
                                    В случае ориентированного графа матрица инцидентности не сильно меняется, за исключением того, что 
                                    на пересечении i-ой вершины и j-ого ребра ставится 1, когда дуга j входит в вершину i и -1, когда 
                                    выходит.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_17_pic_4}
                                        alt="theory_17_pic_4"
                                        width={500}
                                    />
                                    <p>
                                    Для экономии памяти может использоваться список смежности, который представляет из себя набор списков 
                                    по числу вершин в графе. Каждый список представляет из себя перечисление всех смежных данной вершине.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_17_pic_5}
                                        alt="theory_17_pic_5"
                                        width={500}
                                    />
                                    <p>
                                    В случае ориентированного графа список смежности выглядит аналогичным образом.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_17_pic_6}
                                        alt="theory_17_pic_6"
                                        width={500}
                                    />
                                    <p>
                                    В некоторых случаях удобнее использовать список рёбер. Он представляет собой перечисление всех рёбер 
                                    графа. Пример приведен ниже.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_17_pic_7}
                                        alt="theory_17_pic_7"
                                        width={350}
                                    />
                                    <p>
                                        <i> 
                                        Упражнение:
                                        Подумайте, а какой вариант хранения графа в памяти компьютера самый оптимальный. Почему?
                                        </i>
                                    </p>
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_18">
                                    <h1> Обходы графа </h1>
                                    <br></br>
                                    <p>
                                    Пришла пора рассмотреть первые алгоритмы на графах. К классическим алгоритмам относятся обходы графов. 
                                    Под обходом графа обычно понимают процесс систематического просмотра всех вершин или рёбер графа, 
                                    чтобы найти некоторые вершины, удовлетворяющие определённым условиям. Мы рассмотрим обход в ширину 
                                    и обход в глубину.
                                    </p>
                                    <p>
                                    Обход в глубину заключается в систематическом просмотре вершин графа и прохождении его ветвями. 
                                    Иными словами, идея поиска в глубину — когда возможные пути по рёбрам, выходящим из вершин, 
                                    разветвляются, нужно сначала полностью исследовать одну ветку и только потом переходить к другим 
                                    веткам (если они останутся нерассмотренными).
                                    </p>
                                    <p>
                                        Опишем алгоритм поиска в глубину:
                                        <br></br>
                                        <i>Шаг 1.</i> Все вершины графа отмечаем, как не посещенные. Выбирается первая вершина и 
                                        помечается как посещённая.
                                        <br></br>
                                        <i>Шаг 2.</i> Для последней помеченной как посещённой вершины выбирается смежная вершина, которая 
                                        первая помеченная как не посещенная, и ей присваивается значение посещённой. Если таких вершин нет, 
                                        то берётся предыдущая помеченная вершина.
                                        <br></br>
                                        <i>Шаг 3.</i> Повторяем шаг 2 до тех пор, пока все вершины не будут помечены как посещённые.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_18_pic_1}
                                        alt="theory_18_pic_1"
                                        width={500}
                                    />
                                    <p>
                                    Пример реализации приведён ниже.
                                    </p>
                                    <p>
                                        <pre><code>
                                            {'DFS(graph, v, used):'}
                                            <br></br>
                                            {'    used[v] = 1'}
                                            <br></br>
                                            {'    for (var u : graph[v])'}
                                            <br></br>
                                            {'        if (!used[u])'}
                                            <br></br>
                                            {'           DFS(graph, u, used)'}
                                        </code></pre>
                                    </p>
                                    <p>
                                        <i> 
                                        Упражнение:
                                        Попробуйте выполнить алгоритм поиска в глубину пошагово для графа.
                                        </i>
                                    </p>
                                    <p>
                                    Обратите внимание, сейчас мы посмотрели на рекурсивную реализацию. Конечно, преимущество 
                                    использования рекурсивного подхода заключается в простоте его написания, однако, рекурсивный 
                                    подход имеет свои ограничения.
                                    </p>
                                    <p>
                                    Можно переписать алгоритм поиска в глубину с использованием особых структур данных. Например, стека.
                                    </p>
                                    <p>
                                        Опишем алгоритм поиска в глубину в нерекурсивной форме:
                                        <br></br>
                                        <i>Шаг 1.</i> Все вершины графа отмечаем, как не посещённые. Выбирается первая вершина и помечается 
                                        как посещённая. Эту вершину кладем в контейнер — стек.
                                        <br></br>
                                        <i>Шаг 2.</i> Пока стек не пустой извлекаем последнюю добавленную вершину, а затем просматриваем 
                                        все смежные с ней не посещённые вершины и помещаем их в стек. Порядок выхода вершин из стека и 
                                        будет порядком обхода вершин графа.
                                    </p>
                                    <p>
                                    Пример работы не рекурсивного алгоритма можно посмотреть на анимации.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_18_pic_2}
                                        alt="theory_18_pic_2"
                                        width={500}
                                    />
                                    <p>
                                    Пример реализации приведён ниже.
                                    </p>
                                    <p>
                                        <pre><code>
                                            {'DFS(graph, v, used):'}
                                            <br></br>
                                            {'    stack q'}
                                            <br></br>
                                            {'    q.push(v)'}
                                            <br></br>
                                            {'    used[v] = 1'}
                                            <br></br>
                                            {'    while(!q.empty())'}
                                            <br></br>
                                            {'      v = q.front()'}
                                            <br></br>
                                            {'      q.pop()'}
                                            <br></br>
                                            {'      for (var to : graph[v]):'}
                                            <br></br>
                                            {'        if (!used[to]):'}
                                            <br></br>
                                            {'          used[to] = true'}
                                            <br></br>
                                            {'          q.push(to)'}
                                        </code></pre>
                                    </p>
                                    <p>
                                    Ещё один способ обхода графа — обход в ширину. Основное его отличие в том, что сначала исследуются 
                                    смежные вершины, а уже потом вершины на следующем уровне. Иначе говоря, сначала исследуются все 
                                    вершины, смежные с начальной вершиной (вершина с которой начинается обход). Эти вершины находятся 
                                    на расстоянии 1 от начальной. Затем исследуются все вершины на расстоянии 2 от начальной, затем все 
                                    на расстоянии 3 и так далее. Обратим внимание, что при этом для каждой вершины сразу находятся 
                                    длина кратчайшего маршрута от начальной вершины.
                                    </p>
                                    <p>
                                        Опишем алгоритм поиска в ширину:
                                        <br></br>
                                        <i>Шаг 1.</i> Всем вершинам графа присваивается значение не посещённой. Выбирается первая вершина и 
                                        помечается как посещённая и заносится в очередь.
                                        <br></br>
                                        <i>Шаг 2.</i> Посещается первая вершина из очереди (если она не помечена как посещённая). Все её 
                                        соседние вершины заносятся в очередь. После этого она удаляется из очереди.
                                        <br></br>
                                        <i>Шаг 3.</i> Повторяется шаг 2 до тех пор, пока очередь не станет пустой.
                                    </p>
                                    <p>
                                    Пример реализации приведён ниже.
                                    </p>
                                    <p>
                                        <pre><code>
                                            {'BFS(graph, v, used):'}
                                            <br></br>
                                            {'    queue q'}
                                            <br></br>
                                            {'    q.push(v)'}
                                            <br></br>
                                            {'    used[v] = 1'}
                                            <br></br>
                                            {'    while(!q.empty())'}
                                            <br></br>
                                            {'      v = q.front()'}
                                            <br></br>
                                            {'      q.pop()'}
                                            <br></br>
                                            {'      for (var to : graph[v]):'}
                                            <br></br>
                                            {'        if (!used[to]):'}
                                            <br></br>
                                            {'          used[to] = true'}
                                            <br></br>
                                            {'          q.push(to)'}
                                        </code></pre>
                                    </p>
                                    <p>
                                        <i> 
                                        Упражнение:
                                        Подумайте, какое отличие алгоритма поиска в ширину от алгоритма поиска в глубину?
                                        </i>
                                    </p>
                                    <p>
                                        Асимптотическая сложность алгоритма поиска в глубину и ширину — O(V + E), где V — число вершин, а 
                                        E — число рёбер и дуг. Обходы графов могут применяться для решения задач, связанных с теорией 
                                        графов:
                                        <br></br>
                                        - Волновой алгоритм поиска пути в лабиринте
                                        <br></br>
                                        - Волновая трассировка печатных плат
                                        <br></br>
                                        - Поиск компонент связности в графе
                                        <br></br>
                                        - Поиск кратчайшего пути между двумя узлами невзвешенного графа
                                        <br></br>
                                        - Поиск в пространстве состояний: нахождение решения задачи с наименьшим числом ходов, если каждое 
                                        состояние системы можно представить вершиной графа, а переходы из одного состояния в другое — 
                                        рёбрами графа
                                        <br></br>
                                        - Нахождение кратчайшего цикла в ориентированном невзвешенном графе
                                        <br></br>
                                        - Нахождение всех вершин и рёбер, лежащих на каком-либо кратчайшем пути между двумя вершинами
                                        <br></br>
                                        - Поиск увеличивающего пути в алгоритме Форда-Фалкерсона (алгоритм Эдмондса-Карпа)
                                    </p>
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_19">
                                    <h1> Алгоритм нахождения компонент связности в графе </h1>
                                    <br></br>
                                    <p>
                                    Алгоритмы поиска в глубину и ширину находят широкое применение и могут использоваться в других 
                                    алгоритмах. Рассмотрим один из таких алгоритмов для поиска компонент связности в графе. Под 
                                    компонентой связности в графе понимают множество вершин графа достижимых попарно и рёбра их 
                                    связывающие. Для поиска компонент связности необходимо из каждой не посещённой вершины запускать 
                                    алгоритм обхода, накапливая результаты каждого в отдельный контейнер. Пример ниже поможет понять 
                                    алгоритм.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_19_pic_1}
                                        alt="theory_19_pic_1"
                                        width={350}
                                    />
                                    <p>
                                    Асимптотическая сложность нахождения компонент связности в графе — O(V + E), где V — число вершин, 
                                    а E — число рёбер и дуг.
                                    </p>
                                    <p>
                                        <i> 
                                        Упражнение:
                                        Попробуйте реализовать данный алгоритм.
                                        </i>
                                    </p>
                               </Tab.Pane>

                               <Tab.Pane eventKey="theory_20">
                                    <h1> Задача поиска кратчайшего пути в графе </h1>
                                    <br></br>
                                    <p>
                                    Зачастую в графах требуется находить между вершинами кратчайшие пути. Один из алгоритмов нахождения 
                                    кратчайших путей между всеми парами вершин — алгоритм Дейкстры. Алгоритм работает только для графов 
                                    без рёбер отрицательного веса.
                                    </p>
                                    <p>
                                    Асимптотическая сложность нахождения компонент связности в графе — O(V + E), где V — число вершин, 
                                    а E — число рёбер и дуг.
                                    </p>
                                    <p>
                                        Опишем принцип работы алгоритма Дейкстры:
                                        <br></br>
                                        <i>Шаг 1.</i> Всем вершинам, за исключением первой, присваивается вес равный бесконечности, а 
                                        первой вершине — 0.
                                        <br></br>
                                        <i>Шаг 2.</i> Все вершины не посещены.
                                        <br></br>
                                        <i>Шаг 3.</i> Первая вершина объявляется текущей.
                                        <br></br>
                                        <i>Шаг 4.</i> Вес всех невыделенных вершин пересчитывается по формуле: вес невыделенной вершины 
                                        есть минимальное число из старого веса данной вершины, суммы веса текущей вершины и веса ребра, 
                                        соединяющего текущую вершину с невыделенной.
                                        <br></br>
                                        <i>Шаг 5.</i> Среди невыделенных вершин ищется вершина с минимальным весом. Если такова не найдена, 
                                        то есть вес всех вершин равен бесконечности, то маршрута не существует. Следовательно, выход. Иначе, 
                                        текущей становится найденная вершина. Она же выделяется.
                                        <br></br>
                                        <i>Шаг 6.</i> Если текущей вершиной оказывается конечная, то путь найден, и его вес есть вес 
                                        конечной вершины.
                                        <br></br>
                                        <i>Шаг 7.</i> Переход на шаг 4.
                                    </p>
                                    <p>
                                    Пример работы алгоритма показан на картинке ниже.
                                    </p>
                                    <img
                                        className="d-block m-auto"
                                        src={theory_20_pic_1}
                                        alt="theory_20_pic_1"
                                        width={500}
                                    />
                                    <p>
                                    Посмотрим на реализацию.
                                    </p>
                                    <p>
                                        <pre><code>
                                            {'Dijkstra(graph, start, finish, used):'}
                                            <br></br>
                                            {'    vector d(n, inf), p(n, -1)'}
                                            <br></br>
                                            {'    n = len(graph)'}
                                            <br></br>
                                            {'    graph[v] = 1'}
                                            <br></br>
                                            {'    for (int i = 0; i < n; ++i)'}
                                            <br></br>
                                            {'      int v = -1'}
                                            <br></br>
                                            {'      for (int j = 0; j < n; ++j)'}
                                            <br></br>
                                            {'        if (!used[j] and (v == -1 or d[j] < d[v]))'}
                                            <br></br>
                                            {'          v = j'}
                                            <br></br>
                                            {'      used[v] = true'}
                                            <br></br>
                                            {'      for (int j = 0; j < len(graph[v]); ++j)'}
                                            <br></br>
                                            {'        to = graph[v][i].vertex'}
                                            <br></br>
                                            {'        len = graph[v][i].edge'}
                                            <br></br>
                                            {'        if (d[v] + len < d[to])'}
                                            <br></br>
                                            {'          d[to] = d[v] + len'}
                                            <br></br>
                                            {'          p[to] = v'}
                                        </code></pre>
                                    </p>
                                    <p>
                                    Асимптотическая сложность алгоритма Дейкстры — O(V + E), где V — число вершин, а E — число рёбер и дуг.
                                    </p>
                                    <p>
                                        <i> 
                                        Упражнение:
                                        Подумайте, как восстановить путь используя введённый массив p?
                                        </i>
                                    </p>
                                    <p>
                                        <i> 
                                        Упражнение:
                                        Как изменится кратчайший путь, если все веса рёбер увеличить на какое-то число?
                                        </i>
                                    </p>
                                    <p>
                                        <i> 
                                        Упражнение:
                                        Как изменится кратчайший путь, если все веса рёбер увеличить в какое-то число раз?
                                        </i>
                                    </p>
                                    <p>
                                        <i> 
                                        Упражнение:
                                        Подумайте, почему алгоритм работает только для графов без рёбер отрицательного веса?
                                        </i>
                                    </p>
                               </Tab.Pane>
                           </Tab.Content>
                        </Col>
                    </Row>
                </Tab.Container>
            </Container>
        )
    }
}